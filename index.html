<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub PDF Viewer with Enhanced Annotations</title>
    <!-- Include PDF.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <!-- Add PDF-Lib for better annotation handling -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/downloadjs@1.4.7"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin: 0 auto;
            overflow: hidden;
        }
        h1 {
            color: #24292e;
            margin-bottom: 20px;
        }
        #container {
            display: flex;
            height: calc(100vh - 100px);
        }
        #file-list {
            width: 20%;
            background: #f6f8fa;
            padding: 15px;
            border-radius: 5px;
            margin-right: 2%;
            overflow-y: auto;
        }
        #main-content {
            width: 78%;
            display: flex;
            flex-direction: column;
        }
        #toolbar {
            background: #f6f8fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #pdf-container {
            position: relative;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;  /* Changed from auto to hidden */
        }
        #pdf-viewer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        #pdf-canvas {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
            touch-action: none;  /* Added */
        }
        #annotation-canvas {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
            touch-action: none;  /* Added */
            cursor: crosshair;
        }
        .file-link {
            display: block;
            padding: 8px;
            margin-bottom: 5px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 3px;
            color: #0366d6;
            text-decoration: none;
            cursor: pointer;
        }
        .file-link:hover {
            background: #f1f8ff;
        }
        .file-link.active {
            background: #0366d6;
            color: white;
        }
        .loading-message {
            text-align: center;
            padding: 20px;
            color: #586069;
        }
        #pdf-buttons {
            margin-bottom: 10px;
        }
        .button-group {
            margin-right: 15px;
            display: inline-block;
        }
        button {
            margin: 0 2px;
            padding: 5px 10px;
            background: #0366d6;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #0256b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        button.active {
            background: #05a167;
        }
        input[type="color"] {
            vertical-align: middle;
            width: 25px;
            height: 25px;
            padding: 0;
            border: none;
            cursor: pointer;
        }
        select {
            height: 25px;
            margin: 0 5px;
        }
        #text-input {
            position: absolute;
            display: none;
            border: 1px dashed #0366d6;
            background: transparent;
            font-family: Arial;
            z-index: 1000;  /* Updated */
            padding: 5px;
            resize: none;
            overflow: hidden;
            min-width: 100px;  /* Ensure minimum width */
            min-height: 20px;  /* Ensure minimum height */
        }
        #status-message {
            font-style: italic;
            color: #586069;
        }
    </style>
</head>
<body>
    <h1>GitHub Files Viewer with Enhanced Annotations</h1>
    
    <div id="container">
        <div id="file-list">
            <div class="loading-message">Loading files...</div>
        </div>
        
        <div id="main-content">
            <div id="toolbar">
                <div id="pdf-buttons">
                    <div class="button-group">
                        <button id="prev" disabled>← Previous</button>
                        <span id="page-info">Page <span id="page-num">0</span> / <span id="page-count">0</span></span>
                        <button id="next" disabled>Next →</button>
                    </div>
                    
                    <div class="button-group">
                        <button id="zoom-out">-</button>
                        <span id="zoom-level">100%</span>
                        <button id="zoom-in">+</button>
                    </div>
                </div>
                
                <div id="annotation-tools">
                    <button id="draw-tool" title="Draw">Draw</button>
                    <button id="text-tool" title="Add Text">Text</button>
                    <button id="eraser-tool" title="Eraser">Eraser</button>
                    <button id="select-tool" title="Select">Select</button>
                    <input type="color" id="color-picker" value="#FF0000" title="Color">
                    <select id="line-width" title="Line Width">
                        <option value="1">Thin</option>
                        <option value="3" selected>Medium</option>
                        <option value="5">Thick</option>
                        <option value="10">Very Thick</option>
                    </select>
                    <button id="reset-viewer" title="Reset Viewer">Reset</button>
                    <button id="clear-annotations" title="Clear All Annotations">Clear</button>
                    <button id="save-annotations" title="Save Annotations">Save</button>
                    <button id="download-pdf" title="Download PDF with Annotations">Download PDF</button>
                    <button id="practice" title="Generate Practice Questions">Practice</button>
                </div>
            </div>
            
            <div id="pdf-container">
                <div id="pdf-viewer">
                    <canvas id="pdf-canvas"></canvas>
                    <canvas id="annotation-canvas"></canvas>
                    <textarea id="text-input"></textarea>
                </div>
                <div id="status-message"></div>
            </div>
        </div>
    </div>

<script>
// Add fallback PDF URL
const FALLBACK_PDF_URL = "https://raw.githubusercontent.com/mozilla/pdf.js/ba2edeae/web/compressed.tracemonkey-pldi-09.pdf";

// Set up PDF.js
const pdfjsLib = window['pdfjs-dist/build/pdf'];
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

// Variables for PDF viewing
let pdfDoc = null;
let pdfBytes = null; // Store the PDF bytes for PDF-Lib
let pageNum = 1;
let pageRendering = false;
let pageNumPending = null;
let scale = 1.0;
let currentPdfUrl = '';
let currentPdfName = '';
let currentFileLink = null;
let pdfCanvas = document.getElementById('pdf-canvas');
let pdfCtx = pdfCanvas.getContext('2d');
let annotationCanvas = document.getElementById('annotation-canvas');
let annotCtx = annotationCanvas.getContext('2d');
let pdfContainer = document.getElementById('pdf-container');

// Variables for drawing
let isDrawing = false;
let lastX = 0;
let lastY = 0;
let currentTool = 'draw'; // 'draw', 'text', 'eraser', 'select'
let lineWidth = 3;
let strokeColor = '#FF0000';
let textInput = document.getElementById('text-input');
let textPosition = { x: 0, y: 0 };
let textSize = 16;
let selectedTextId = null;
let isMovingText = false;

// Enhanced annotation storage system
let documentAnnotations = {};

// Add these debug functions at the top of your script
function debugLog(message) {
    console.log(`[DEBUG] ${message}`);
}

function getCanvasCoordinates(e, canvas) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
    };
}

// Function to fetch GitHub files but display them as lesson numbers in chronological order
async function fetchGitHubFiles() {
    const owner = 'Laurentsandler';
    const repo = 'unit7';
    const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/Lessons`;
    const fileListDiv = document.getElementById('file-list');

    // Mapping from file IDs (ending characters) to lesson numbers
    const lessonMap = {
        's35vv2vcxyiqdvakd5lntb5icnfz': 1,
        'zkky9m8o3vsozyu4xen4utf3f8gs': 2,
        'yeqilxepw0xooighf6weuppph15f': 3,
        'zlmmbcibwdq3sldaxgowpotarx3e': 4,
        'neih48su5xw48htkbhyalx4fu3gl': 5,
        '4fvqet2a7pbdncorckoyq2w523jz': 6,
        'hcpb6rhvh788e3g5ifh063ibocy4': 7,
        '50yqxgbiwuyx0ldixe5stlvylp1c': 8,
        '0vamnafs0v4g79xk7ypf0lwe9fg3': 9,
        'lki4e8pygdvxidpr9zxd4lx07lr7': 10,
        '7pkw2mkjt199qrvm2alnup79d2e5': 11,
        'd56egt3gsn786wh7hcbwfhkil390': 12,
        '0u3ik9oupgfxr8yrgfv4eamm7qym': 13,
        '22vegpfis9ni48syauiatmuthlyw': 14,
        'ccfwve652ntbgzajvwioyb0ilgtb': 15,
        'aixr5h1i1a9998j2r7qouyggu3tv': 16,
        'f6jifba1pkyvh8mzshrcctihjkin': 17
    };

    try {
        const response = await fetch(apiUrl);
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const files = await response.json();
        
        if (!Array.isArray(files)) {
            throw new Error('The API did not return an array of files');
        }

        // Clear loading message
        fileListDiv.innerHTML = '';

        // Process files and create a sorted array with lesson information
        const lessonFiles = [];
        files.forEach(file => {
            // Extract the file ID (assuming file name contains the ID)
            const fileId = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension if any
            
            // Check if we have a lesson number for this file
            if (lessonMap[fileId]) {
                lessonFiles.push({
                    lessonNumber: lessonMap[fileId],
                    fileUrl: `https://raw.githubusercontent.com/${owner}/${repo}/main/${file.path}`,
                    fileName: file.name
                });
            } else {
                // File not in our mapping, add it with a high lesson number to put at the end
                lessonFiles.push({
                    lessonNumber: 1000, // Put unmapped files at the end
                    fileUrl: `https://raw.githubusercontent.com/${owner}/${repo}/main/${file.path}`,
                    fileName: file.name
                });
            }
        });

        // Sort by lesson number
        lessonFiles.sort((a, b) => a.lessonNumber - b.lessonNumber);

        // Add file links to the sidebar in sorted order
        lessonFiles.forEach(lesson => {
            const fileLink = document.createElement('a');
            fileLink.className = 'file-link';
            
            // Display as Lesson X if it's a known lesson, otherwise use the original file name
            if (lesson.lessonNumber < 1000) {
                fileLink.textContent = `Lesson ${lesson.lessonNumber}`;
            } else {
                fileLink.textContent = lesson.fileName;
            }
            
            fileLink.onclick = function() {
                // Remove active class from previous link
                if (currentFileLink) {
                    currentFileLink.classList.remove('active');
                }
                
                // Add active class to current link
                this.classList.add('active');
                currentFileLink = this;
                
                loadPDF(lesson.fileUrl, fileLink.textContent);
            };
            fileListDiv.appendChild(fileLink);
        });

        // Load the first file by default if there are any files
        if (lessonFiles.length > 0) {
            const firstFileElement = fileListDiv.querySelector('.file-link');
            if (firstFileElement) {
                firstFileElement.classList.add('active');
                currentFileLink = firstFileElement;
                loadPDF(lessonFiles[0].fileUrl, firstFileElement.textContent);
            }
        }
        
        // Load annotations from local storage
        loadAnnotations();
        
    } catch (error) {
        fileListDiv.innerHTML = `<div class="loading-message">Error: ${error.message}<br>Loading fallback PDF for testing.</div>`;
        console.error('Error fetching files:', error);
        
        // Add fallback link
        const fileLink = document.createElement('a');
        fileLink.className = 'file-link active';
        fileLink.textContent = "Test PDF";
        fileLink.onclick = function() {
            loadPDF(FALLBACK_PDF_URL, "Test PDF");
        };
        fileListDiv.appendChild(fileLink);
        currentFileLink = fileLink;
        
        // Load the fallback PDF
        loadPDF(FALLBACK_PDF_URL, "Test PDF");
    }
}

// Function to load and display a PDF
async function loadPDF(url, fileName) {
    try {
        // Cancel any ongoing rendering
        if (pageRendering) {
            pageRendering = false;
            pageNumPending = null;
        }
        
        // Save annotations of current PDF before loading a new one
        if (currentPdfName) {
            saveAnnotations();
        }
        
        // Reset page number and update current URL/name
        pageNum = 1;
        currentPdfUrl = url;
        currentPdfName = fileName;
        
        // Clear current annotation canvas
        clearAnnotationCanvas();
        
        updateStatus('Loading PDF...');
        
        // Fetch and load the PDF
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.status}`);
        }
        
        const arrayBuffer = await response.arrayBuffer();
        pdfBytes = new Uint8Array(arrayBuffer);
        
        // Make sure any previous document is properly destroyed
        if (pdfDoc) {
            pdfDoc.destroy();
            pdfDoc = null;
        }
        
        // Load the new document
        const loadingTask = pdfjsLib.getDocument({data: pdfBytes});
        
        loadingTask.promise.then(function(pdf) {
            pdfDoc = pdf;
            document.getElementById('page-count').textContent = pdf.numPages;
            
            // Enable navigation buttons if there are multiple pages
            document.getElementById('prev').disabled = (pdf.numPages === 1);
            document.getElementById('next').disabled = (pdf.numPages === 1);
            
            // Render the first page
            renderPage(pageNum);
            
        }).catch(function(error) {
            console.error('Error loading PDF:', error);
            updateStatus('Error loading PDF: ' + error.message);
            
            // Show error on the canvas
            pdfCtx.fillStyle = "#f6f8fa";
            pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
            pdfCtx.fillStyle = "#d73a49";
            pdfCtx.font = "20px Arial";
            pdfCtx.textAlign = "center";
            pdfCtx.fillText("Error loading PDF", pdfCanvas.width/2, pdfCanvas.height/2-20);
            pdfCtx.font = "16px Arial";
            pdfCtx.fillText("This may not be a PDF file or it's not accessible", pdfCanvas.width/2, pdfCanvas.height/2+20);
        });
    } catch (error) {
        console.error('Error loading PDF:', error);
        updateStatus('Error loading PDF: ' + error.message);
    }
}

// Enhanced function to render a specific page of the PDF
function renderPage(num) {
    if (pageRendering) {
        // If another page is currently rendering, put this request in the queue
        pageNumPending = num;
        return;
    }
    
    pageRendering = true;
    updateStatus('Rendering page...');
    
    // Get page
    pdfDoc.getPage(num).then(function(page) {
        // Adjust canvas size to the page
         const viewport = page.getViewport({ scale });
    
    // Set both canvas dimensions
    pdfCanvas.height = viewport.height;
    pdfCanvas.width = viewport.width;
    annotationCanvas.height = viewport.height;
    annotationCanvas.width = viewport.width;
        
        // Clear the canvas before rendering new page
        pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        
        // Create a new render context for each render operation
        const renderContext = {
            canvasContext: pdfCtx,
            viewport: viewport
        };
        
        const renderTask = page.render(renderContext);
        
        // Wait for rendering to finish
        renderTask.promise.then(function() {
            pageRendering = false;
            updateStatus('Page rendered.');
            
            // Load annotations for this page/file
            renderAnnotations();
            
            // Check if there's a pending page
            if (pageNumPending !== null) {
                // New page has been requested while this one was rendering
                const pendingNum = pageNumPending;
                pageNumPending = null;
                renderPage(pendingNum);
            }
            
        }).catch(function(error) {
            pageRendering = false;
            updateStatus('Error rendering page: ' + error);
            console.error('Render task error:', error);
        });
    }).catch(function(error) {
        pageRendering = false;
        updateStatus('Error getting page: ' + error);
        console.error('Get page error:', error);
    });
    
    // Update page counters
    document.getElementById('page-num').textContent = num;
}

// Functions to navigate between pages
function queueRenderPage(num) {
    if (pageRendering) {
        pageNumPending = num;
    } else {
        renderPage(num);
    }
}

function onPrevPage() {
    if (pageNum <= 1) {
        return;
    }
    pageNum--;
    queueRenderPage(pageNum);
}

function onNextPage() {
    if (pageNum >= pdfDoc.numPages) {
        return;
    }
    pageNum++;
    queueRenderPage(pageNum);
}

// Function to update status message
function updateStatus(message) {
    const statusElement = document.getElementById('status-message');
    statusElement.textContent = message;
    // Clear message after 3 seconds
    setTimeout(() => {
        if (statusElement.textContent === message) {
            statusElement.textContent = '';
        }
    }, 3000);
}

// Function for zoom in
function zoomIn() {
    if (scale >= 3.0) return; // Max zoom
    scale += 0.25;
    updateZoomDisplay();
    queueRenderPage(pageNum);
}

// Function for zoom out
function zoomOut() {
    if (scale <= 0.5) return; // Min zoom
    scale -= 0.25;
    updateZoomDisplay();
    queueRenderPage(pageNum);
}

// Update zoom level display
function updateZoomDisplay() {
    document.getElementById('zoom-level').textContent = `${Math.round(scale * 100)}%`;
}

// New Enhanced Annotation System
// Instead of separate storages, use a unified structure
function initializeAnnotationsForCurrentDocument() {
    if (!currentPdfName) return; // Add this check
    
    if (!documentAnnotations[currentPdfName]) {
        documentAnnotations[currentPdfName] = {};
    }
    
    if (!documentAnnotations[currentPdfName][pageNum]) {
        documentAnnotations[currentPdfName][pageNum] = {
            drawings: [],
            texts: []
        };
    }
}

// Draw annotations on the canvas
function renderAnnotations() {
    // Clear the annotation canvas first
    clearAnnotationCanvas();
    
    if (!currentPdfName) return;
    
    initializeAnnotationsForCurrentDocument();
    const pageAnnotations = documentAnnotations[currentPdfName][pageNum];
    
    // Render drawing annotations
    for (const drawing of pageAnnotations.drawings) {
        annotCtx.beginPath();
        annotCtx.strokeStyle = drawing.color;
        annotCtx.lineWidth = drawing.lineWidth;
        annotCtx.lineJoin = 'round';
        annotCtx.lineCap = 'round';
        
        // Draw the path
        if (drawing.points.length > 0) {
            annotCtx.moveTo(drawing.points[0].x, drawing.points[0].y);
            
            for (let i = 1; i < drawing.points.length; i++) {
                annotCtx.lineTo(drawing.points[i].x, drawing.points[i].y);
            }
        }
        
        annotCtx.stroke();
    }
    
    // Render text annotations
    for (const text of pageAnnotations.texts) {
        renderTextAnnotation(text);
    }
}

// Function to render a text annotation
function renderTextAnnotation(textObj) {
    // Render the text on the canvas
    annotCtx.font = `${textObj.size}px Arial`;
    annotCtx.fillStyle = textObj.color;
    annotCtx.textBaseline = 'top';
    annotCtx.fillText(textObj.text, textObj.x, textObj.y);
    
    // Draw a small "x" delete button
    const textWidth = annotCtx.measureText(textObj.text).width;
    const xSize = textObj.size * 0.8; // Size of the "x" relative to text
    
    annotCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
    annotCtx.fillRect(textObj.x + textWidth + 2, textObj.y - 2, xSize, xSize);
    
    annotCtx.fillStyle = 'white';
    annotCtx.font = `${xSize * 0.8}px Arial`;
    annotCtx.textBaseline = 'top';
    annotCtx.fillText('×', textObj.x + textWidth + 3, textObj.y - 1);
    
    // Add event listener for "x" click
    annotationCanvas.addEventListener('click', function(e) {
        const coords = getCanvasCoordinates(e, annotationCanvas);
        if (coords.x >= textObj.x + textWidth + 2 && coords.x <= textObj.x + textWidth + 2 + xSize &&
            coords.y >= textObj.y - 2 && coords.y <= textObj.y - 2 + xSize) {
            deleteTextAnnotation(textObj.id);
        }
    });
}

// Function to delete text annotation
function deleteTextAnnotation(textId) {
    if (!currentPdfName || !documentAnnotations[currentPdfName] || !documentAnnotations[currentPdfName][pageNum]) return;
    
    const textIndex = documentAnnotations[currentPdfName][pageNum].texts.findIndex(t => t.id === textId);
    if (textIndex !== -1) {
        documentAnnotations[currentPdfName][pageNum].texts.splice(textIndex, 1);
        renderAnnotations();
        saveAnnotations();
    }
}

// Function to clear annotation canvas
function clearAnnotationCanvas() {
    annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
}

// Function to clear all annotations on current page
function clearCurrentPageAnnotations() {
    if (!currentPdfName) return;
    
    initializeAnnotationsForCurrentDocument();
    
    // Clear annotations for current page
    documentAnnotations[currentPdfName][pageNum] = {
        drawings: [],
        texts: []
    };
    
    // Clear the canvas
    clearAnnotationCanvas();
    updateStatus('Annotations cleared from current page');
    saveAnnotations();
}

// Generate unique ID for text annotations
function generateUniqueId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

// Function to show text input
function showTextInput(x, y) {
    debugLog(`Showing text input at x=${x}, y=${y}`);
    
    const rect = annotationCanvas.getBoundingClientRect();
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    // Store position for later use
    textPosition = {x, y};
    
    // Calculate absolute position
    const absoluteX = rect.left + x + scrollLeft;
    const absoluteY = rect.top + y + scrollTop;
    
    debugLog(`Absolute position: x=${absoluteX}, y=${absoluteY}`);
    
    // Position and show the text input
    textInput.style.position = 'absolute';
    textInput.style.left = `${absoluteX}px`;
    textInput.style.top = `${absoluteY}px`;
    textInput.style.display = 'block';
    textInput.style.zIndex = '1000';  // Ensure it's above other elements
    textInput.style.color = strokeColor;
    textInput.style.fontSize = `${textSize}px`;
    textInput.value = '';
    textInput.style.minWidth = '100px';  // Ensure minimum width
    textInput.style.minHeight = '20px';  // Ensure minimum height
    
    // Focus the input
    setTimeout(() => {
        textInput.focus();
    }, 10);
}

// Function to hide text input
function hideTextInput() {
    textInput.style.display = 'none';
    textInput.value = '';
}

// Function to commit text entry (continuing from where it was cut off)
function commitText() {
    if (!textInput.value.trim()) {
        hideTextInput();
        return;
    }
    
    initializeAnnotationsForCurrentDocument();
    
    // Check if we're editing an existing text
    if (selectedTextId) {
        const textIndex = documentAnnotations[currentPdfName][pageNum].texts.findIndex(t => t.id === selectedTextId);
        
        if (textIndex !== -1) {
            // Update existing text
            documentAnnotations[currentPdfName][pageNum].texts[textIndex].text = textInput.value;
        } else {
            // Add new text if somehow the ID is not found
            addNewTextAnnotation();
        }
        
        selectedTextId = null;
    } else {
        // Add new text
        addNewTextAnnotation();
    }
    
    hideTextInput();
    renderAnnotations();
    saveAnnotations();
}

// Helper function to add new text annotation
function addNewTextAnnotation() {
    const textAnnotation = {
        id: generateUniqueId(),
        text: textInput.value,
        x: textPosition.x,
        y: textPosition.y,
        size: textSize,
        color: strokeColor
    };
    
    documentAnnotations[currentPdfName][pageNum].texts.push(textAnnotation);
}

// Set active tool
function setActiveTool(tool) {
    currentTool = tool;
    
    // Update button appearances
    document.getElementById('draw-tool').classList.remove('active');
    document.getElementById('text-tool').classList.remove('active');
    document.getElementById('eraser-tool').classList.remove('active');
    document.getElementById('select-tool').classList.remove('active');
    
    // Cancel any ongoing operations
    isDrawing = false;
    isMovingText = false;
    
    if (tool === 'draw') {
        document.getElementById('draw-tool').classList.add('active');
        annotationCanvas.style.cursor = 'crosshair';
    } else if (tool === 'text') {
        document.getElementById('text-tool').classList.add('active');
        annotationCanvas.style.cursor = 'text';
    } else if (tool === 'eraser') {
        //document.getElementById('eraser-tool').classList.add('active');
        //annotationCanvas.style.cursor = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAC/SURBVDhP7ZLBDYMwDEWzVwbJHhmCuTJHJskOOXfuMARrdIn8ayUIuKGHSnnSlyDxbH+HgH/EdKKuaxtvyKJ4gs9GP81YwjCsgqIowrZt4VTuz3OxbVv4JfKmaRQWRXEJUmRZpjCO4xDwCCkiG1jXtcIwDEPAI6TIAM/zXGHf9yHgEVJkgOM4Kuz7PgQ8QorMtu/7KoT6vhdSSHYAUsQF67pWIZYQC2ZZJqSQ7ACkKOZ5rrCqqitt20bGsWf/Cdz8McwbZMJ4JupGFPoAAAAASUVORK5CYII="), auto`;
    } else if (tool === 'select') {
        document.getElementById('select-tool').classList.add('active');
        annotationCanvas.style.cursor = 'default';
    }
    
    // Hide text input if shown
    if (textInput.style.display === 'block') {
        if (textInput.value.trim() !== '') {
            commitText();
        } else {
            hideTextInput();
        }
    }
}

// Event handlers for drawing
function startDrawing(e) {
    e.preventDefault();
    debugLog(`Tool: ${currentTool}`);
    
    if (!currentPdfName || !documentAnnotations[currentPdfName]) {
        debugLog('No PDF loaded or annotations not initialized');
        return;
    }
    
    const coords = getCanvasCoordinates(e, annotationCanvas);
    debugLog(`Start coordinates: x=${coords.x}, y=${coords.y}`);
    
    // Initialize if needed
    if (!documentAnnotations[currentPdfName][pageNum]) {
        documentAnnotations[currentPdfName][pageNum] = {
            drawings: [],
            texts: []
        };
    }
    
    if (currentTool === 'text') {
        debugLog('Showing text input');
        showTextInput(coords.x, coords.y);
        return;
    }
    
    if (currentTool === 'draw') {
        isDrawing = true;
        lastX = coords.x;
        lastY = coords.y;
        
        debugLog('Starting new drawing path');
        // Start new drawing path
        documentAnnotations[currentPdfName][pageNum].drawings.push({
            color: strokeColor,
            lineWidth: lineWidth,
            points: [{x: coords.x, y: coords.y}]
        });
        
        // Set up canvas context
        annotCtx.beginPath();
        annotCtx.strokeStyle = strokeColor;
        annotCtx.lineWidth = lineWidth;
        annotCtx.lineJoin = 'round';
        annotCtx.lineCap = 'round';
        annotCtx.moveTo(coords.x, coords.y);
    }
}

function draw(e) {
    e.preventDefault();
    
    if (!isDrawing || currentTool !== 'draw') {
        return;
    }
    
    const coords = getCanvasCoordinates(e, annotationCanvas);
    debugLog(`Drawing coordinates: x=${coords.x}, y=${coords.y}`);
    
    if (!documentAnnotations[currentPdfName] || 
        !documentAnnotations[currentPdfName][pageNum] || 
        !documentAnnotations[currentPdfName][pageNum].drawings.length) {
        debugLog('No active drawing path');
        return;
    }
    
    // Get current drawing
    const currentDrawing = documentAnnotations[currentPdfName][pageNum].drawings[
        documentAnnotations[currentPdfName][pageNum].drawings.length - 1
    ];
    
    // Add new point
    currentDrawing.points.push({x: coords.x, y: coords.y});
    
    // Draw line
    annotCtx.beginPath();
    annotCtx.strokeStyle = currentDrawing.color;
    annotCtx.lineWidth = currentDrawing.lineWidth;
    annotCtx.lineJoin = 'round';
    annotCtx.lineCap = 'round';
    annotCtx.moveTo(lastX, lastY);
    annotCtx.lineTo(coords.x, coords.y);
    annotCtx.stroke();
    
    lastX = coords.x;
    lastY = coords.y;
}

function stopDrawing() {
    if (isDrawing) {
        isDrawing = false;
        saveAnnotations();
    }
    
    if (isMovingText) {
        isMovingText = false;
        selectedTextId = null;
        saveAnnotations();
    }
}

// Load annotations from localStorage
function loadAnnotations() {
    try {
        const savedAnnotations = localStorage.getItem('pdfAnnotations');
        
        if (savedAnnotations) {
            documentAnnotations = JSON.parse(savedAnnotations);
            updateStatus('Annotations loaded from local storage.');
        }
    } catch (error) {
        console.error('Error loading annotations:', error);
        updateStatus('Error loading saved annotations: ' + error.message);
    }
}

// Save annotations to localStorage
function saveAnnotations() {
    if (!currentPdfName) return;
    
    try {
        localStorage.setItem('pdfAnnotations', JSON.stringify(documentAnnotations));
    } catch (error) {
        console.error('Error saving annotations:', error);
        updateStatus('Error saving annotations: ' + error.message);
    }
}

// Function to download PDF with annotations
async function downloadAnnotatedPdf() {
    if (!pdfBytes) {
        updateStatus('No PDF loaded to download');
        return;
    }
    
    updateStatus('Preparing PDF download...');
    
    try {
        // Load the PDF document with PDF-Lib
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        const pages = pdfDoc.getPages();
        
        // Check if we have any annotations to add
        let hasAnnotations = false;
        for (const pageKey in documentAnnotations[currentPdfName]) {
            const pageAnnots = documentAnnotations[currentPdfName][pageKey];
            if (pageAnnots && (pageAnnots.texts.length > 0 || pageAnnots.drawings.length > 0)) {
                hasAnnotations = true;
                break;
            }
        }
        
        if (!hasAnnotations) {
            updateStatus('No annotations to add to PDF');
            return;
        }
        
        // Process each page with annotations
        for (const pageKey in documentAnnotations[currentPdfName]) {
            const pageNum = parseInt(pageKey);
            if (isNaN(pageNum) || pageNum <= 0 || pageNum > pages.length) continue;
            
            const pageAnnots = documentAnnotations[currentPdfName][pageKey];
            if (!pageAnnots) continue;
            
            const page = pages[pageNum - 1]; // PDF-Lib uses 0-based indexing
            
            // Get page dimensions
            const { width, height } = page.getSize();
            
            // Add text annotations
            if (pageAnnots.texts && pageAnnots.texts.length > 0) {
                for (const textAnnot of pageAnnots.texts) {
                    // Convert color from hex to RGB
                    const color = hexToRgb(textAnnot.color);
                    
                    page.drawText(textAnnot.text, {
                        x: textAnnot.x,
                        y: height - textAnnot.y - textAnnot.size, // Convert to PDF coordinates (origin at bottom-left)
                        size: textAnnot.size,
                        color: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255)
                    });
                }
            }
            
            // Add drawing annotations
            if (pageAnnots.drawings && pageAnnots.drawings.length > 0) {
                for (const drawing of pageAnnots.drawings) {
                    if (!drawing.points || drawing.points.length < 2) continue; // Skip single points
                    
                    // Convert color
                    const color = hexToRgb(drawing.color);
                    
                    // Create an SVG path
                    let svgPath = `M ${drawing.points[0].x} ${height - drawing.points[0].y} `;
                    for (let i = 1; i < drawing.points.length; i++) {
                        svgPath += `L ${drawing.points[i].x} ${height - drawing.points[i].y} `;
                    }
                    
                    // Draw the SVG path
                    page.drawSvgPath(svgPath, {
                        color: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255),
                        borderWidth: drawing.lineWidth,
                        borderColor: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255)
                    });
                }
            }
        }
        
        // Save the PDF
        const newPdfBytes = await pdfDoc.save();
        
        // Create a download link
        const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
        const filename = currentPdfName.replace(/\.[^/.]+$/, '') + '_annotated.pdf';
        
        // Use the download.js library
        download(blob, filename, 'application/pdf');
        
        updateStatus('PDF downloaded with annotations');
    } catch (error) {
        console.error('Error creating annotated PDF:', error);
        updateStatus('Error creating annotated PDF: ' + error.message);
    }
}
// Helper function to convert hex color to RGB (continuing from where it was cut off)
function hexToRgb(hex) {
    // Remove the # if present
    hex = hex.replace(/^#/, '');
    
    // Parse r, g, b values
    let bigint = parseInt(hex, 16);
    let r = (bigint >> 16) & 255;
    let g = (bigint >> 8) & 255;
    let b = bigint & 255;
    
    return { r, g, b };
}

// Double-click handler for editing text
function setupTextEditing() {
    annotationCanvas.addEventListener('dblclick', function(e) {
        if (currentTool !== 'select') return;
        
        const rect = annotationCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Check if double-clicked on text
        if (documentAnnotations[currentPdfName] && 
            documentAnnotations[currentPdfName][pageNum] &&
            documentAnnotations[currentPdfName][pageNum].texts) {
            
            const texts = documentAnnotations[currentPdfName][pageNum].texts;
            
            for (const textObj of texts) {
                annotCtx.font = `${textObj.size}px Arial`;
                const textWidth = annotCtx.measureText(textObj.text).width;
                
                if (x >= textObj.x && x <= textObj.x + textWidth &&
                    y >= textObj.y && y <= textObj.y + textObj.size) {
                    
                    // Set up text input for editing
                    selectedTextId = textObj.id;
                    textPosition.x = textObj.x;
                    textPosition.y = textObj.y;
                    
                    const viewportX = rect.left + textObj.x;
                    const viewportY = rect.top + textObj.y;
                    
                    textInput.style.position = 'absolute';
                    textInput.style.left = viewportX + 'px';
                    textInput.style.top = viewportY + 'px';
                    textInput.style.display = 'block';
                    textInput.style.color = textObj.color;
                    textInput.style.fontSize = textObj.size + 'px';
                    textInput.value = textObj.text;
                    
                    setTimeout(() => {
                        textInput.focus();
                        textInput.select();
                    }, 10);
                    
                    return;
                }
            }
        }
    });
}

// Function to handle viewer reset
function resetViewer() {
    // Cancel any pending operations
    if (pdfDoc) {
        try {
            pdfDoc.destroy();
        } catch (error) {
            console.error('Error destroying PDF document:', error);
        }
        pdfDoc = null;
    }
    
    // Clear canvas
    pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
    annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    
    // Reset state
    pageNum = 1;
    pageRendering = false;
    pageNumPending = null;
    scale = 1.0;
    updateZoomDisplay();
    
    // Reload current PDF if available
    if (currentPdfUrl && currentPdfName) {
        loadPDF(currentPdfUrl, currentPdfName);
    }
    
    updateStatus('Viewer reset');
}

// Function to ensure proper canvas setup
function setupCanvas() {
    debugLog('Setting up canvas');
    
    // Make sure both canvases have the same dimensions as the container
    const container = document.getElementById('pdf-container');
    const containerRect = container.getBoundingClientRect();
    
    pdfCanvas.width = containerRect.width;
    pdfCanvas.height = containerRect.height;
    annotationCanvas.width = containerRect.width;
    annotationCanvas.height = containerRect.height;
    
    // Clear any existing transformations
    pdfCtx.setTransform(1, 0, 0, 1, 0, 0);
    annotCtx.setTransform(1, 0, 0, 1, 0, 0);
    
    // Enable image smoothing
    pdfCtx.imageSmoothingEnabled = true;
    annotCtx.imageSmoothingEnabled = true;
}

// Set up all event handlers
function setupEventHandlers() {
    // PDF navigation buttons
    document.getElementById('prev').addEventListener('click', onPrevPage);
    document.getElementById('next').addEventListener('click', onNextPage);
    document.getElementById('reset-viewer').addEventListener('click', resetViewer);
    document.getElementById('practice').addEventListener('click', generatePracticeQuestions);
    // Zoom buttons
    document.getElementById('zoom-in').addEventListener('click', zoomIn);
    document.getElementById('zoom-out').addEventListener('click', zoomOut);
    
    // Tool buttons
    document.getElementById('draw-tool').addEventListener('click', () => setActiveTool('draw'));
    document.getElementById('text-tool').addEventListener('click', () => setActiveTool('text'));
    document.getElementById('eraser-tool').addEventListener('click', () => setActiveTool('eraser'));
    document.getElementById('select-tool').addEventListener('click', () => setActiveTool('select'));
    document.getElementById('clear-annotations').addEventListener('click', clearCurrentPageAnnotations);
    document.getElementById('save-annotations').addEventListener('click', saveAnnotations);
    document.getElementById('download-pdf').addEventListener('click', downloadAnnotatedPdf);
    
    // Color and line width controls
    document.getElementById('color-picker').addEventListener('input', function(e) {
        strokeColor = e.target.value;
    });
    
    document.getElementById('line-width').addEventListener('change', function(e) {
        lineWidth = parseInt(e.target.value);
    });
    
    // Drawing event listeners
    annotationCanvas.addEventListener('mousedown', startDrawing);
    annotationCanvas.addEventListener('mousemove', draw);
    annotationCanvas.addEventListener('mouseup', stopDrawing);
    annotationCanvas.addEventListener('mouseout', stopDrawing);
    
    // Text input event listeners
    textInput.addEventListener('blur', commitText);
    textInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            commitText();
        }
        
        // Allow escape to cancel
        if (e.key === 'Escape') {
            hideTextInput();
            selectedTextId = null;
        }
    });
    
    // Set up text editing via double-click
    setupTextEditing();
    
    // Handle touch events for mobile devices
    annotationCanvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            startDrawing(mouseEvent);
        }
    }, { passive: false });
    
    annotationCanvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            draw(mouseEvent);
        }
    }, { passive: false });
    
    annotationCanvas.addEventListener('touchend', stopDrawing);
    
    // Update canvas setup when window is resized
    window.addEventListener('resize', setupCanvas);
}

// Initialize the application
function initApp() {
    setupCanvas();
    setActiveTool('draw');
    setupEventHandlers();
    fetchGitHubFiles();
    
    // Add error handling for worker
    pdfjsLib.GlobalWorkerOptions.onError = function(error) {
        console.error('PDF.js Worker Error:', error);
        updateStatus('PDF Worker Error: ' + error.message);
    };
}

// Start the application when DOM is fully loaded
document.addEventListener('DOMContentLoaded', initApp);

// Function to handle the API request and response
async function generatePracticeQuestions() {
    if (!currentPdfUrl) {
        updateStatus('No PDF loaded to generate practice questions');
        return;
    }

    updateStatus('Generating practice questions...');

    try {
        const prompt = 'Generate 10 practice questions based on the questions in the PDF';
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const questions = response.text.split('\n').filter(q => q.trim() !== '');
        redirectToPracticePage(questions);
    } catch (error) {
        console.error('Error generating practice questions:', error);
        updateStatus('Error generating practice questions: ' + error.message);
    }
}

// Function to redirect to the practice page with generated questions
function redirectToPracticePage(questions) {
    const practicePageUrl = 'practice.html';
    const queryParams = new URLSearchParams({ questions: JSON.stringify(questions) });
    window.location.href = `${practicePageUrl}?${queryParams.toString()}`;
}
// Google Gemini API integration for generating practice questions with answers
let model = null;
const GEMINI_API_KEY = "AIzaSyCPUd25EGEK1s43iL5IOhELxfyLbUHpL6o"; // Replace with your actual API key
const GEMINI_MODEL = "gemini-1.5-flash"; // Using the specified model

// Function to initialize the Gemini model
async function initializeModel() {
    try {
        model = {
            name: "Google Gemini",
            version: "1.5-flash",
            ready: true,
            apiKey: GEMINI_API_KEY
        };
        
        console.log("Gemini API model initialized successfully");
        return true;
    } catch (error) {
        console.error("Failed to initialize Gemini model:", error);
        return false;
    }
}

// Function to generate practice questions using Gemini API
async function generatePracticeQuestions() {
    if (!pdfDoc) {
        updateStatus('No PDF loaded to generate questions from');
        return;
    }
    
    updateStatus('Generating practice questions with Google Gemini...');
    
    try {
        // Initialize the model if it hasn't been already
        if (!model) {
            const initialized = await initializeModel();
            if (!initialized) {
                throw new Error("Failed to initialize Gemini model");
            }
        }
        
        // Get the text content from the current page
        const page = await pdfDoc.getPage(pageNum);
        const textContent = await page.getTextContent();
        const text = textContent.items.map(item => item.str).join(' ');
        
        if (text.trim().length < 50) {
            updateStatus('Not enough text content to generate questions');
            return;
        }
        
        // Extract additional context information
        const contextInfo = {
            fileName: currentPdfName,
            pageNumber: pageNum,
            totalPages: pdfDoc.numPages
        };
        
        // Call Gemini API to generate questions
        const questionData = await callGeminiAPI(text, contextInfo);
        
        // Display questions in a side panel
        displayPracticeQuestionsPanel(questionData);
        
    } catch (error) {
        console.error('Error generating practice questions:', error);
        updateStatus('Error generating practice questions: ' + error.message);
    }
}

// Function to call the Google Gemini API with improved prompt
async function callGeminiAPI(textContent, contextInfo) {
    try {
        // Prepare the prompt for Gemini with specific instructions
        const prompt = `
        I need to generate practice questions based on the following content from a PDF document.

        Document name: ${contextInfo.fileName}
        Page: ${contextInfo.pageNumber} of ${contextInfo.totalPages}
        
        Content:
        ${textContent.substring(0, 8000)}
        
        IMPORTANT INSTRUCTIONS:
        1. Generate 5 practice questions that are SIMILAR in style and difficulty to what might be in the document, but NOT identical to any questions already present in the text.
        2. For each question, also provide a correct answer that would be considered complete and accurate.
        3. Format your response as JSON that I can parse, using this exact structure:
        [
          {
            "question": "Question text here?",
            "answer": "Correct answer here."
          },
          ...and so on for all 5 questions
        ]
        
        The questions should test understanding and critical thinking about the content. Make sure the answer explains the reasoning clearly.
        `;
        
        // Make the API call to Gemini 1.5 Flash
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-goog-api-key': model.apiKey
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    maxOutputTokens: 2048,
                }
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Gemini API error: ${errorData.error?.message || response.statusText}`);
        }
        
        const data = await response.json();
        
        // Extract the generated content from the response
        let generatedText = data.candidates[0].content.parts[0].text;
        
        // Try to find and parse the JSON part of the response
        let jsonMatch = generatedText.match(/(\[[\s\S]*\])/);
        let questionsData = [];
        
        if (jsonMatch && jsonMatch[1]) {
            try {
                questionsData = JSON.parse(jsonMatch[1]);
            } catch (e) {
                console.error("Failed to parse JSON from response:", e);
            }
        }
        
        // If we couldn't parse JSON properly, try a more lenient approach
        if (questionsData.length === 0) {
            // Try to extract question-answer pairs using regex
            const regex = /"question"\s*:\s*"([^"]*)"\s*,\s*"answer"\s*:\s*"([^"]*)"/g;
            let match;
            while ((match = regex.exec(generatedText)) !== null) {
                questionsData.push({
                    question: match[1],
                    answer: match[2]
                });
            }
        }
        
        // If we still don't have structured data, create a fallback
        if (questionsData.length === 0) {
            // Split by numbers as a last resort
            const lines = generatedText.split('\n');
            for (let i = 0; i < lines.length; i++) {
                const questionMatch = lines[i].match(/^\d+\.\s+(.+)$/);
                if (questionMatch && i + 1 < lines.length) {
                    questionsData.push({
                        question: questionMatch[1],
                        answer: lines[i+1]
                    });
                    i++; // Skip the answer line in next iteration
                }
            }
        }
        
        return questionsData.length > 0 ? questionsData : [
            { 
                question: "The AI generated content in an unexpected format.", 
                answer: "Please try again or check the API response: " + generatedText.substring(0, 200) + "..."
            }
        ];
        
    } catch (error) {
        console.error("Error calling Gemini API:", error);
        return [
            { 
                question: "Failed to generate questions using Gemini AI.", 
                answer: "Error: " + error.message 
            }
        ];
    }
}

// Function to display practice questions in a side panel
// Function to display practice questions in a side panel
function displayPracticeQuestionsPanel(questionsData) {
    // Remove any existing panel
    const existingPanel = document.getElementById('practice-questions-panel');
    if (existingPanel) {
        existingPanel.remove();
    }
    
    // Create panel container
    const panel = document.createElement('div');
    panel.id = 'practice-questions-panel';
    
    // Change position from absolute to fixed
    panel.style.position = 'fixed'; 
    panel.style.top = '100px'; // Position below the header
    panel.style.right = '0';
    panel.style.width = '350px'; // Slightly narrower than before
    panel.style.height = 'calc(100vh - 120px)'; // Account for top position
    panel.style.backgroundColor = '#f8f9fa';
    panel.style.borderLeft = '1px solid #ddd';
    panel.style.boxShadow = '-2px 0 5px rgba(0, 0, 0, 0.1)';
    panel.style.overflowY = 'auto';
    panel.style.padding = '15px';
    panel.style.zIndex = '1000'; // Lower z-index so it doesn't overlap other elements
    panel.style.display = 'flex';
    panel.style.flexDirection = 'column';
    
    // Add header
    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    header.style.marginBottom = '15px';
    header.style.borderBottom = '1px solid #ddd';
    header.style.paddingBottom = '10px';
    
    const title = document.createElement('h3');
    title.textContent = 'Practice Questions';
    title.style.margin = '0';
    title.style.color = '#24292e';
    
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '&times;';
    closeButton.style.background = 'none';
    closeButton.style.border = 'none';
    closeButton.style.fontSize = '24px';
    closeButton.style.cursor = 'pointer';
    closeButton.style.color = '#586069';
    closeButton.onclick = () => {
        panel.remove();
        // Restore original PDF container size
        document.getElementById('main-content').style.width = '78%';
        document.getElementById('pdf-container').style.width = '100%';
    };
    
    header.appendChild(title);
    header.appendChild(closeButton);
    panel.appendChild(header);
    
    // Add document info
    const documentInfo = document.createElement('p');
    documentInfo.textContent = `Generated from: ${currentPdfName} (Page ${pageNum} of ${pdfDoc.numPages})`;
    documentInfo.style.fontSize = '14px';
    documentInfo.style.color = '#586069';
    documentInfo.style.marginBottom = '15px';
    panel.appendChild(documentInfo);
    
    // Add questions
    const questionsContainer = document.createElement('div');
    questionsContainer.style.flexGrow = '1';
    questionsContainer.style.overflowY = 'auto';
    
    questionsData.forEach((item, index) => {
        const questionBlock = document.createElement('div');
        questionBlock.className = 'practice-question';
        questionBlock.style.marginBottom = '20px';
        questionBlock.style.backgroundColor = 'white';
        questionBlock.style.padding = '15px';
        questionBlock.style.borderRadius = '5px';
        questionBlock.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
        
        // Question number and text
        const questionHeader = document.createElement('div');
        questionHeader.innerHTML = `<strong>Question ${index + 1}:</strong> ${item.question}`;
        questionHeader.style.marginBottom = '10px';
        questionHeader.style.lineHeight = '1.5';
        questionBlock.appendChild(questionHeader);
        
        // Answer textarea
        const userAnswerDiv = document.createElement('div');
        userAnswerDiv.style.marginBottom = '10px';
        
        const textarea = document.createElement('textarea');
        textarea.className = 'answer-input';
        textarea.placeholder = "Write your answer here...";
        textarea.style.width = '100%';
        textarea.style.padding = '8px';
        textarea.style.minHeight = '80px';
        textarea.style.borderRadius = '3px';
        textarea.style.border = '1px solid #ddd';
        textarea.style.resize = 'vertical';
        textarea.style.marginTop = '5px';
        textarea.style.boxSizing = 'border-box';
        
        userAnswerDiv.appendChild(textarea);
        questionBlock.appendChild(userAnswerDiv);
        
        // Check answer button
        const checkAnswerBtn = document.createElement('button');
        checkAnswerBtn.textContent = 'Check Answer';
        checkAnswerBtn.style.backgroundColor = '#0366d6';
        checkAnswerBtn.style.color = 'white';
        checkAnswerBtn.style.border = 'none';
        checkAnswerBtn.style.padding = '6px 12px';
        checkAnswerBtn.style.borderRadius = '3px';
        checkAnswerBtn.style.cursor = 'pointer';
        checkAnswerBtn.style.marginRight = '10px';
        
        // Answer container (initially hidden)
        const answerContainer = document.createElement('div');
        answerContainer.className = 'correct-answer';
        answerContainer.style.display = 'none';
        answerContainer.style.backgroundColor = '#f1f8e9';
        answerContainer.style.padding = '10px';
        answerContainer.style.borderRadius = '3px';
        answerContainer.style.marginTop = '10px';
        answerContainer.style.borderLeft = '3px solid #66bb6a';
        
        const answerHeader = document.createElement('div');
        answerHeader.innerHTML = '<strong>Suggested Answer:</strong>';
        answerHeader.style.marginBottom = '5px';
        
        const answerText = document.createElement('div');
        answerText.textContent = item.answer;
        answerText.style.lineHeight = '1.5';
        
        answerContainer.appendChild(answerHeader);
        answerContainer.appendChild(answerText);
        
        // Button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '10px';
        buttonContainer.appendChild(checkAnswerBtn);
        
        // Show answer without checking
        const showAnswerBtn = document.createElement('button');
        showAnswerBtn.textContent = 'Show Answer';
        showAnswerBtn.style.backgroundColor = '#6c757d';
        showAnswerBtn.style.color = 'white';
        showAnswerBtn.style.border = 'none';
        showAnswerBtn.style.padding = '6px 12px';
        showAnswerBtn.style.borderRadius = '3px';
        showAnswerBtn.style.cursor = 'pointer';
        showAnswerBtn.onclick = () => {
            answerContainer.style.display = answerContainer.style.display === 'none' ? 'block' : 'none';
            showAnswerBtn.textContent = answerContainer.style.display === 'none' ? 'Show Answer' : 'Hide Answer';
        };
        
        buttonContainer.appendChild(showAnswerBtn);
        questionBlock.appendChild(buttonContainer);
        
        // Add answer container
        questionBlock.appendChild(answerContainer);
        
        questionsContainer.appendChild(questionBlock);
    });
    
    panel.appendChild(questionsContainer);
    
    // Add buttons at the bottom
    const panelButtons = document.createElement('div');
    panelButtons.style.borderTop = '1px solid #ddd';
    panelButtons.style.paddingTop = '15px';
    panelButtons.style.marginTop = '10px';
    panelButtons.style.display = 'flex';
    panelButtons.style.justifyContent = 'space-between';
    
    const regenerateBtn = document.createElement('button');
    regenerateBtn.textContent = 'Generate New Questions';
    regenerateBtn.style.backgroundColor = '#28a745';
    regenerateBtn.style.color = 'white';
    regenerateBtn.style.border = 'none';
    regenerateBtn.style.padding = '8px 16px';
    regenerateBtn.style.borderRadius = '3px';
    regenerateBtn.style.cursor = 'pointer';
    regenerateBtn.onclick = generatePracticeQuestions;
    
    panelButtons.appendChild(regenerateBtn);
    panel.appendChild(panelButtons);
    
    // Add to body instead of as a child of another element
    document.body.appendChild(panel);
    
    // Adjust main content width to make room for the panel
    document.getElementById('main-content').style.width = '78%';
    document.getElementById('pdf-container').style.width = '100%';
}
// Function to evaluate a user's answer against the correct answer
async function evaluateAnswer(question, correctAnswer, userAnswer) {
    try {
        const prompt = `
        You are evaluating a student's answer to a practice question.
        
        Question: ${question}
        
        Correct answer: ${correctAnswer}
        
        Student's answer: ${userAnswer}
        
        Provide a brief but helpful feedback on the student's answer. Focus on:
        1. Whether the main concepts are correct
        2. What's missing if anything important was left out
        3. Any misconceptions that should be corrected
        4. Offer encouraging feedback when aspects are correct
        
        Keep your feedback concise (50-100 words) and constructive.
        `;
        
        // Make the API call to Gemini 1.5 Flash
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-goog-api-key': model.apiKey
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.3,
                    maxOutputTokens: 512,
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`API error: ${response.statusText}`);
        }
        
        const data = await response.json();
        return data.candidates[0].content.parts[0].text.trim();
    } catch (error) {
        console.error("Error evaluating answer:", error);
        return "Unable to evaluate your answer at this time. Please compare with the suggested answer.";
    }
}

// Helper function to extract color components from hex color string
function hexToRgb(hex) {
    // Remove # if present
    hex = hex.replace('#', '');
    
    // Convert 3-digit hex to 6-digit
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    
    // Parse hex values
    return {
        r: parseInt(hex.substr(0, 2), 16),
        g: parseInt(hex.substr(2, 2), 16),
        b: parseInt(hex.substr(4, 2), 16)
    };
}

// Add the event listener for the practice button
document.addEventListener('DOMContentLoaded', function() {
    // Existing event listeners may already be set up in your code
    
    // Add event listener for practice button
    const practiceBtn = document.getElementById('practice');
    if (practiceBtn) {
        practiceBtn.addEventListener('click', generatePracticeQuestions);
    } else {
        console.error("Practice button not found in the DOM");
    }
});

// Add custom CSS for better styling
const styleElement = document.createElement('style');
styleElement.textContent = `
    #practice-questions-panel {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        transition: all 0.3s ease;
    }
    
    #practice-questions-panel button {
        transition: background-color 0.2s ease;
    }
    
    #practice-questions-panel button:hover {
        opacity: 0.9;
    }
    
    .practice-question {
        transition: transform 0.2s ease;
    }
    
    .practice-question:hover {
        transform: translateY(-2px);
    }
    
    .answer-input:focus {
        border-color: #0366d6 !important;
        outline: none;
        box-shadow: 0 0 0 2px rgba(3, 102, 214, 0.2);
    }
`;
document.head.appendChild(styleElement);
</script>
</body>
</html>
