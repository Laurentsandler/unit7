<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub PDF Viewer with Annotations</title>
    <!-- Include PDF.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin: 0 auto;
            overflow: hidden;
        }
        h1 {
            color: #24292e;
            margin-bottom: 20px;
        }
        #container {
            display: flex;
            height: calc(100vh - 100px);
        }
        #file-list {
            width: 20%;
            background: #f6f8fa;
            padding: 15px;
            border-radius: 5px;
            margin-right: 2%;
            overflow-y: auto;
        }
        #main-content {
            width: 78%;
            display: flex;
            flex-direction: column;
        }
        #toolbar {
            background: #f6f8fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #pdf-container {
            position: relative;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: auto;
        }
        #pdf-viewer {
            position: relative;
        }
        #pdf-canvas {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
        }
        #annotation-canvas {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
            cursor: crosshair;
        }
        .file-link {
            display: block;
            padding: 8px;
            margin-bottom: 5px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 3px;
            color: #0366d6;
            text-decoration: none;
            cursor: pointer;
        }
        .file-link:hover {
            background: #f1f8ff;
        }
        .file-link.active {
            background: #0366d6;
            color: white;
        }
        .loading-message {
            text-align: center;
            padding: 20px;
            color: #586069;
        }
        #pdf-buttons {
            margin-bottom: 10px;
        }
        .button-group {
            margin-right: 15px;
            display: inline-block;
        }
        button {
            margin: 0 2px;
            padding: 5px 10px;
            background: #0366d6;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #0256b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        button.active {
            background: #05a167;
        }
        input[type="color"] {
            vertical-align: middle;
            width: 25px;
            height: 25px;
            padding: 0;
            border: none;
            cursor: pointer;
        }
        select {
            height: 25px;
            margin: 0 5px;
        }
        #text-input {
            display: none;
            position: absolute;
            border: 1px dashed #0366d6;
            background: transparent;
            font-family: Arial;
            z-index: 3;
            padding: 5px;
            resize: none;
            overflow: hidden;
        }
        #status-message {
            font-style: italic;
            color: #586069;
        }
    </style>
</head>
<body>
    <h1>GitHub Files Viewer with Annotations</h1>
    
    <div id="container">
        <div id="file-list">
            <div class="loading-message">Loading files...</div>
        </div>
        
        <div id="main-content">
            <div id="toolbar">
                <div id="pdf-buttons">
                    <div class="button-group">
                        <button id="prev" disabled>← Previous</button>
                        <span id="page-info">Page <span id="page-num">0</span> / <span id="page-count">0</span></span>
                        <button id="next" disabled>Next →</button>
                    </div>
                    
                    <div class="button-group">
                        <button id="zoom-out">-</button>
                        <span id="zoom-level">100%</span>
                        <button id="zoom-in">+</button>
                    </div>
                </div>
                
                <div id="annotation-tools">
                    <button id="draw-tool" title="Draw">Draw</button>
                    <button id="text-tool" title="Add Text">Text</button>
                    <button id="eraser-tool" title="Eraser">Eraser</button>
                    <button id="select-tool" title="Select">Select</button> <!-- Pe3ed -->
                    <input type="color" id="color-picker" value="#FF0000" title="Color">
                    <select id="line-width" title="Line Width">
                        <option value="1">Thin</option>
                        <option value="3" selected>Medium</option>
                        <option value="5">Thick</option>
                        <option value="10">Very Thick</option>
                    </select>
                    <button id="clear-annotations" title="Clear All Annotations">Clear</button>
                    <button id="save-annotations" title="Save Annotations to Local Storage">Save</button>
                </div>
            </div>
            
            <div id="pdf-container">
                <div id="pdf-viewer">
                    <canvas id="pdf-canvas"></canvas>
                    <canvas id="annotation-canvas"></canvas>
                    <textarea id="text-input"></textarea>
                </div>
                <div id="status-message"></div>
            </div>
        </div>
    </div>

    <script>
// Set up PDF.js
const pdfjsLib = window['pdfjs-dist/build/pdf'];
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

// Variables for PDF viewing
let pdfDoc = null;
let pageNum = 1;
let pageRendering = false;
let pageNumPending = null;
let scale = 1.0;
let currentPdfUrl = '';
let currentPdfName = '';
let currentFileLink = null;
let pdfCanvas = document.getElementById('pdf-canvas');
let pdfCtx = pdfCanvas.getContext('2d');
let annotationCanvas = document.getElementById('annotation-canvas');
let annotCtx = annotationCanvas.getContext('2d');
let pdfContainer = document.getElementById('pdf-container');

// Variables for drawing
let isDrawing = false;
let lastX = 0;
let lastY = 0;
let currentTool = 'draw'; // 'draw', 'text', 'eraser', 'move', 'select'
let lineWidth = 3;
let strokeColor = '#FF0000';
let textInput = document.getElementById('text-input');
let textPosition = { x: 0, y: 0 };
let textSize = 16;
let annotations = {}; // Object to store annotations by file and page
let textAnnotations = {}; // Store text annotations separately for editing
let selectedTextId = null; // ID of text being moved
let isMovingText = false; // Flag for text movement

// Function to fetch GitHub files
async function fetchGitHubFiles() {
    const owner = 'Laurentsandler';
    const repo = 'unit7';
    const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/Lessons`;
    const fileListDiv = document.getElementById('file-list');

    try {
        const response = await fetch(apiUrl);
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const files = await response.json();
        
        if (!Array.isArray(files)) {
            throw new Error('The API did not return an array of files');
        }

        // Clear loading message
        fileListDiv.innerHTML = '';

        // Add file links to the sidebar
        files.forEach(file => {
            const fileUrl = `https://raw.githubusercontent.com/${owner}/${repo}/main/${file.path}`;
            const fileLink = document.createElement('a');
            fileLink.className = 'file-link';
            fileLink.textContent = file.name;
            fileLink.onclick = function() {
                // Remove active class from previous link
                if (currentFileLink) {
                    currentFileLink.classList.remove('active');
                }
                
                // Add active class to current link
                this.classList.add('active');
                currentFileLink = this;
                
                loadPDF(fileUrl, file.name);
            };
            fileListDiv.appendChild(fileLink);
        });

        // Load the first file by default if there are any files
        if (files.length > 0) {
            const firstFileUrl = `https://raw.githubusercontent.com/${owner}/${repo}/main/${files[0].path}`;
            const firstFileElement = fileListDiv.querySelector('.file-link');
            if (firstFileElement) {
                firstFileElement.classList.add('active');
                currentFileLink = firstFileElement;
            }
            loadPDF(firstFileUrl, files[0].name);
        }
        
        // Load annotations from local storage
        loadAnnotations();
        
    } catch (error) {
        fileListDiv.innerHTML = `<div class="loading-message">Error: ${error.message}<br>Please make sure the 'Lessons' folder exists and contains files.</div>`;
        console.error('Error fetching files:', error);
    }
}

// Function to render a specific page of the PDF
function renderPage(num) {
    pageRendering = true;
    updateStatus('Rendering page...');
    
    // Get page
    pdfDoc.getPage(num).then(function(page) {
        // Adjust canvas size to the page
        const viewport = page.getViewport({ scale });
        pdfCanvas.height = viewport.height;
        pdfCanvas.width = viewport.width;
        
        // Set up annotation canvas to match
        annotationCanvas.width = pdfCanvas.width;
        annotationCanvas.height = pdfCanvas.height;
        
        // Render PDF page into canvas context
        const renderContext = {
            canvasContext: pdfCtx,
            viewport: viewport
        };
        
        const renderTask = page.render(renderContext);
        
        // Wait for rendering to finish
        renderTask.promise.then(function() {
            pageRendering = false;
            updateStatus('Page rendered.');
            
            // Check if there's a pending page
            if (pageNumPending !== null) {
                renderPage(pageNumPending);
                pageNumPending = null;
            }
            
            // Load annotations for this page/file
            loadPageAnnotations();
            
        }).catch(function(error) {
            updateStatus('Error rendering page: ' + error);
            pageRendering = false;
        });
    }).catch(function(error) {
        updateStatus('Error getting page: ' + error);
        pageRendering = false;
    });
    
    // Update page counters
    document.getElementById('page-num').textContent = num;
}

// Functions to navigate between pages
function queueRenderPage(num) {
    if (pageRendering) {
        pageNumPending = num;
    } else {
        renderPage(num);
    }
}

function onPrevPage() {
    if (pageNum <= 1) {
        return;
    }
    pageNum--;
    queueRenderPage(pageNum);
}

function onNextPage() {
    if (pageNum >= pdfDoc.numPages) {
        return;
    }
    pageNum++;
    queueRenderPage(pageNum);
}

// Function to load and display a PDF
async function loadPDF(url, fileName) {
    try {
        // Save annotations of current PDF before loading a new one
        savePageAnnotations();
        
        // Reset page number and update current URL
        pageNum = 1;
        currentPdfUrl = url;
        currentPdfName = fileName;
        
        // Clear current annotation canvas
        clearAnnotationCanvas();
        
        updateStatus('Loading PDF...');
        
        // Fetch and load the PDF
        const loadingTask = pdfjsLib.getDocument(url);
        loadingTask.promise.then(function(pdf) {
            pdfDoc = pdf;
            document.getElementById('page-count').textContent = pdf.numPages;
            
            // Enable navigation buttons if there are multiple pages
            document.getElementById('prev').disabled = (pdf.numPages === 1);
            document.getElementById('next').disabled = (pdf.numPages === 1);
            
            // Render the first page
            renderPage(pageNum);
            
        }, function(error) {
            console.error('Error loading PDF:', error);
            updateStatus('Error loading PDF: ' + error.message);
            
            // Show error on the canvas
            pdfCtx.fillStyle = "#f6f8fa";
            pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
            pdfCtx.fillStyle = "#d73a49";
            pdfCtx.font = "20px Arial";
            pdfCtx.textAlign = "center";
            pdfCtx.fillText("Error loading PDF", pdfCanvas.width/2, pdfCanvas.height/2-20);
            pdfCtx.font = "16px Arial";
            pdfCtx.fillText("This may not be a PDF file or it's not accessible", pdfCanvas.width/2, pdfCanvas.height/2+20);
        });
    } catch (error) {
        console.error('Error loading PDF:', error);
        updateStatus('Error loading PDF: ' + error);
    }
}

// Function to update status message
function updateStatus(message) {
    const statusElement = document.getElementById('status-message');
    statusElement.textContent = message;
    // Clear message after 3 seconds
    setTimeout(() => {
        if (statusElement.textContent === message) {
            statusElement.textContent = '';
        }
    }, 3000);
}

// Function for zoom in
function zoomIn() {
    if (scale >= 3.0) return; // Max zoom
    scale += 0.25;
    updateZoomDisplay();
    queueRenderPage(pageNum);
}

// Function for zoom out
function zoomOut() {
    if (scale <= 0.5) return; // Min zoom
    scale -= 0.25;
    updateZoomDisplay();
    queueRenderPage(pageNum);
}

// Update zoom level display
function updateZoomDisplay() {
    document.getElementById('zoom-level').textContent = `${Math.round(scale * 100)}%`;
}

// Function to set active tool
function setActiveTool(tool) {
    currentTool = tool;
    
    // Update button appearances
    document.getElementById('draw-tool').classList.remove('active');
    document.getElementById('text-tool').classList.remove('active');
    document.getElementById('eraser-tool').classList.remove('active');
    document.getElementById('select-tool').classList.remove('active'); // P2e48
    
    if (tool === 'draw') {
        document.getElementById('draw-tool').classList.add('active');
        annotationCanvas.style.cursor = 'crosshair';
    } else if (tool === 'text') {
        document.getElementById('text-tool').classList.add('active');
        annotationCanvas.style.cursor = 'text';
    } else if (tool === 'eraser') {
        document.getElementById('eraser-tool').classList.add('active');
        annotationCanvas.style.cursor = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAAH6ji2bAAAABGdBTUEAALGPC/xhBQAAAnNJREFUOBGdVL1rU1EcPfdGQytYinQoVoRCi4PJoEMHHUTcFBcFB8HNf8DN[...]';
    } else if (tool === 'select') { // P2e48
        document.getElementById('select-tool').classList.add('active');
        annotationCanvas.style.cursor = 'pointer';
    }
}

// Function to clear annotation canvas
function clearAnnotationCanvas() {
    annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    // Clear text annotations too
    if (textAnnotations[currentPdfName]) {
        textAnnotations[currentPdfName][pageNum] = [];
    }
}

// Function to get annotation storage key
function getAnnotationKey() {
    return `${currentPdfName}_page_${pageNum}`;
}

function savePageAnnotations() {
    if (!currentPdfName) return;
    
    // Store this page's annotations
    if (!annotations[currentPdfName]) {
        annotations[currentPdfName] = {};
    }
    
    // Only save the drawing annotation data, not the text
    // This prevents duplication of text annotations when dragging
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = annotationCanvas.width;
    tempCanvas.height = annotationCanvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Draw only the base annotations without text
    if (annotations[currentPdfName][pageNum]) {
        const img = new Image();
        img.onload = function() {
            tempCtx.drawImage(img, 0, 0);
            annotations[currentPdfName][pageNum] = tempCanvas.toDataURL();
        };
        img.src = annotations[currentPdfName][pageNum];
    } else {
        // If no annotations exist yet
        annotations[currentPdfName][pageNum] = tempCanvas.toDataURL();
    }
    
    // Save text annotations separately
    if (!textAnnotations[currentPdfName]) {
        textAnnotations[currentPdfName] = {};
    }
    // We don't need to do anything else for text annotations as they
    // are already updated in place by reference
}

// Function to load page annotations from memory
function loadPageAnnotations() {
    if (!currentPdfName) return;
    
    const key = getAnnotationKey();
    
    // Check if we have annotations for this page
    if (annotations[currentPdfName] && annotations[currentPdfName][pageNum]) {
        const annotationData = annotations[currentPdfName][pageNum];
        const img = new Image();
        img.onload = function() {
            annotCtx.drawImage(img, 0, 0);
        };
        img.src = annotationData;
    } else {
        clearAnnotationCanvas();
    }
    
    // Render any text annotations
    if (textAnnotations[currentPdfName] && textAnnotations[currentPdfName][pageNum]) {
        for (const textObj of textAnnotations[currentPdfName][pageNum]) {
            renderTextAnnotation(textObj);
        }
    }
}

// Function to render a text annotation with delete button
function renderTextAnnotation(textObj) {
    // Render the text on the canvas
    annotCtx.font = `${textObj.size}px Arial`;
    annotCtx.fillStyle = textObj.color;
    annotCtx.textBaseline = 'top';
    annotCtx.fillText(textObj.text, textObj.x, textObj.y);
    
    // Draw a small "x" delete button
    const textWidth = annotCtx.measureText(textObj.text).width;
    const xSize = textObj.size * 0.8; // Size of the "x" relative to text
    
    annotCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
    annotCtx.fillRect(textObj.x + textWidth + 2, textObj.y - 2, xSize, xSize);
    
    annotCtx.fillStyle = 'white';
    annotCtx.font = `${xSize * 0.8}px Arial`;
    annotCtx.textBaseline = 'top';
    annotCtx.fillText('×', textObj.x + textWidth + 3, textObj.y - 1);
}

// Function to save all annotations to local storage
function saveAnnotations() {
    // First save current page annotations
    savePageAnnotations();
    
    // Then save all to local storage
    try {
        localStorage.setItem('pdfAnnotations', JSON.stringify(annotations));
        localStorage.setItem('pdfTextAnnotations', JSON.stringify(textAnnotations));
        updateStatus('Annotations saved successfully!');
    } catch (error) {
        updateStatus('Error saving annotations: ' + error.message);
        console.error('Error saving annotations:', error);
    }
}

// Function to load all annotations from local storage
function loadAnnotations() {
    try {
        const savedAnnotations = localStorage.getItem('pdfAnnotations');
        const savedTextAnnotations = localStorage.getItem('pdfTextAnnotations');
        
        if (savedAnnotations) {
            annotations = JSON.parse(savedAnnotations);
        }
        
        if (savedTextAnnotations) {
            textAnnotations = JSON.parse(savedTextAnnotations);
        }
        
        updateStatus('Annotations loaded from local storage.');
    } catch (error) {
        updateStatus('Error loading saved annotations: ' + error.message);
        console.error('Error loading annotations:', error);
    }
}

// Generate unique ID for text annotations
function generateUniqueId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

function startDrawing(e) {
    const rect = annotationCanvas.getBoundingClientRect();
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
    
    // Check if clicked on a text annotation delete button
    if (textAnnotations[currentPdfName] && textAnnotations[currentPdfName][pageNum]) {
        for (let i = 0; i < textAnnotations[currentPdfName][pageNum].length; i++) {
            const textObj = textAnnotations[currentPdfName][pageNum][i];
            const textWidth = annotCtx.measureText(textObj.text).width;
            const xSize = textObj.size * 0.8;
            
            // Check if click is on the delete button
            // Allow delete in ANY tool mode, not just select mode
            if (lastX >= textObj.x + textWidth + 2 && 
                lastX <= textObj.x + textWidth + 2 + xSize &&
                lastY >= textObj.y - 2 &&
                lastY <= textObj.y - 2 + xSize) {
                
                console.log('Deleting text annotation:', textObj.text);
                
                // Remove this text annotation
                textAnnotations[currentPdfName][pageNum].splice(i, 1);
                
                // Redraw canvas
                redrawCanvas();
                
                // Save changes
                saveAnnotations();
                return;
            }
            
            // Check if click is on the text itself (for moving)
            // Only allow text selection in select mode
            if (currentTool === 'select' && 
                lastX >= textObj.x && 
                lastX <= textObj.x + textWidth &&
                lastY >= textObj.y &&
                lastY <= textObj.y + textObj.size) {
                
                // Set this text as selected for moving
                selectedTextId = textObj.id;
                isMovingText = true;
                return;
            }
        }
    }
    
    // Hide text input when drawing starts
    if (textInput.style.display === 'block') {
        if (textInput.value.trim() !== '') {
            commitText();
        } else {
            hideTextInput();
        }
    }
    
    // Only set isDrawing if we're not in select mode
    if (currentTool !== 'select') {
        isDrawing = true;
    }
    
    // For text tool, show text input at click position
    if (currentTool === 'text') {
        isDrawing = false;
        showTextInput(lastX, lastY);
        return;
    }
}



function draw(e) {
    const rect = annotationCanvas.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;
    
    // Handle text movement
    if (isMovingText && selectedTextId && currentTool === 'select') {
        if (!textAnnotations[currentPdfName] || !textAnnotations[currentPdfName][pageNum]) return;
        
        // Find the selected text
        const textObj = textAnnotations[currentPdfName][pageNum].find(t => t.id === selectedTextId);
        if (textObj) {
            // Update text position
            textObj.x = currentX - (lastX - textObj.x);
            textObj.y = currentY - (lastY - textObj.y);
            
            // Update last position
            lastX = currentX;
            lastY = currentY;
            
            // Redraw canvas - this will use the updated position
            redrawCanvas();
        }
        return;
    }
    
    // Handle regular drawing
    if (!isDrawing) return;
    
    annotCtx.lineJoin = 'round';
    annotCtx.lineCap = 'round';
    
    if (currentTool === 'draw') {
        annotCtx.globalCompositeOperation = 'source-over';
        annotCtx.strokeStyle = strokeColor;
        annotCtx.lineWidth = lineWidth;
    } else if (currentTool === 'eraser') {
        annotCtx.globalCompositeOperation = 'destination-out';
        annotCtx.lineWidth = lineWidth * 2; // Larger eraser
    }
    // Remove the 'select' condition to prevent early return
    
    annotCtx.beginPath();
    annotCtx.moveTo(lastX, lastY);
    annotCtx.lineTo(currentX, currentY);
    annotCtx.stroke();
    
    lastX = currentX;
    lastY = currentY;
}

function stopDrawing() {
    if (isDrawing) {
        isDrawing = false;
        // Save the current state
        savePageAnnotations();
    }
    
    // Handle text movement completion
    if (isMovingText) {
        isMovingText = false;
        selectedTextId = null;
        // Save changes when text movement is complete
        saveAnnotations();
    }
}

// 5. Modify the redrawCanvas function (around line 737)
function redrawCanvas() {
    // Clear canvas
    annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    
    // Redraw base annotations from image data
    if (annotations[currentPdfName] && annotations[currentPdfName][pageNum]) {
        const annotationData = annotations[currentPdfName][pageNum];
        const img = new Image();
        img.onload = function() {
            annotCtx.drawImage(img, 0, 0);
            
            // Then draw text annotations on top
            drawTextAnnotations();
        };
        img.src = annotationData;
    } else {
        // If no base annotations, just draw text annotations
        drawTextAnnotations();
    }
}

// 6. Add a new helper function for drawing text annotations
function drawTextAnnotations() {
    if (textAnnotations[currentPdfName] && textAnnotations[currentPdfName][pageNum]) {
        for (const textObj of textAnnotations[currentPdfName][pageNum]) {
            renderTextAnnotation(textObj);
        }
    }
}
// Text handling functions
function showTextInput(x, y) {
    // Store the actual position on the canvas for later drawing
    textPosition.x = x;
    textPosition.y = y;
    
    // Calculate position for text input element in viewport coordinates
    const rect = annotationCanvas.getBoundingClientRect();
    const viewportX = rect.left + x;
    const viewportY = rect.top + y;
    
    // Position the text input directly at cursor position
    textInput.style.position = 'absolute';
    textInput.style.left = viewportX + 'px';
    textInput.style.top = viewportY + 'px';
    textInput.style.display = 'block';
    textInput.style.color = strokeColor;
    textInput.style.fontSize = textSize + 'px';
    textInput.value = '';
    
    // Focus on the text input
    setTimeout(() => {
        textInput.focus();
    }, 10);
}

function hideTextInput() {
    textInput.style.display = 'none';
    textInput.value = '';
}

function commitText() {
    if (!textInput.value.trim()) {
        hideTextInput();
        return;
    }
    
    const text = textInput.value;
    
    // Create a text annotation object
    const textObj = {
        id: generateUniqueId(),
        text: text,
        x: textPosition.x,
        y: textPosition.y,
        size: textSize,
        color: strokeColor
    };
    
    // Initialize if needed
    if (!textAnnotations[currentPdfName]) {
        textAnnotations[currentPdfName] = {};
    }
    if (!textAnnotations[currentPdfName][pageNum]) {
        textAnnotations[currentPdfName][pageNum] = [];
    }
    
    // Add to text annotations array
    textAnnotations[currentPdfName][pageNum].push(textObj);
    
    // Draw the text on canvas
    renderTextAnnotation(textObj);
    
    hideTextInput();
    savePageAnnotations();
}

// Set up event listeners
document.addEventListener('DOMContentLoaded', function() {
    // PDF navigation buttons
    document.getElementById('prev').addEventListener('click', onPrevPage);
    document.getElementById('next').addEventListener('click', onNextPage);
    
    // Zoom buttons
    document.getElementById('zoom-in').addEventListener('click', zoomIn);
    document.getElementById('zoom-out').addEventListener('click', zoomOut);
    
    // Tool buttons
    document.getElementById('draw-tool').addEventListener('click', () => setActiveTool('draw'));
    document.getElementById('text-tool').addEventListener('click', () => setActiveTool('text'));
    document.getElementById('eraser-tool').addEventListener('click', () => setActiveTool('eraser'));
    document.getElementById('select-tool').addEventListener('click', () => setActiveTool('select')); // Pe3ed
    document.getElementById('clear-annotations').addEventListener('click', () => {
        clearAnnotationCanvas();
        savePageAnnotations();
    });
    document.getElementById('save-annotations').addEventListener('click', saveAnnotations);
    
    // Color and line width controls
    document.getElementById('color-picker').addEventListener('input', function(e) {
        strokeColor = e.target.value;
    });
    document.getElementById('line-width').addEventListener('change', function(e) {
        lineWidth = parseInt(e.target.value);
    });
    
    // Drawing event listeners
    annotationCanvas.addEventListener('mousedown', startDrawing);
    annotationCanvas.addEventListener('mousemove', draw);
    annotationCanvas.addEventListener('mouseup', stopDrawing);
    annotationCanvas.addEventListener('mouseout', stopDrawing);
    
    // Text input event listeners
    textInput.addEventListener('blur', commitText);
    textInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            commitText();
        }
    });
    
    // Set initial active tool
    setActiveTool('draw');
    
    // Load files when page loads
    fetchGitHubFiles();
});
</script>
</html>

