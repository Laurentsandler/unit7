<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub PDF Viewer with Enhanced Annotations</title>
    <!-- Include PDF.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <!-- Add PDF-Lib for better annotation handling -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/downloadjs@1.4.7"></script>
    <script src="https://unpkg.com/@google-cloud/vertexai"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin: 0 auto;
            overflow: hidden;
        }
        h1 {
            color: #24292e;
            margin-bottom: 20px;
        }
        #container {
            display: flex;
            height: calc(100vh - 100px);
        }
        #file-list {
            width: 20%;
            background: #f6f8fa;
            padding: 15px;
            border-radius: 5px;
            margin-right: 2%;
            overflow-y: auto;
        }
        #main-content {
            width: 78%;
            display: flex;
            flex-direction: column;
        }
        #toolbar {
            background: #f6f8fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #pdf-container {
            position: relative;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;  /* Changed from auto to hidden */
        }
        #pdf-viewer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        #pdf-canvas {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
            touch-action: none;  /* Added */
        }
        #annotation-canvas {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
            touch-action: none;  /* Added */
            cursor: crosshair;
        }
        .file-link {
            display: block;
            padding: 8px;
            margin-bottom: 5px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 3px;
            color: #0366d6;
            text-decoration: none;
            cursor: pointer;
        }
        .file-link:hover {
            background: #f1f8ff;
        }
        .file-link.active {
            background: #0366d6;
            color: white;
        }
        .loading-message {
            text-align: center;
            padding: 20px;
            color: #586069;
        }
        #pdf-buttons {
            margin-bottom: 10px;
        }
        .button-group {
            margin-right: 15px;
            display: inline-block;
        }
        button {
            margin: 0 2px;
            padding: 5px 10px;
            background: #0366d6;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #0256b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        button.active {
            background: #05a167;
        }
        input[type="color"] {
            vertical-align: middle;
            width: 25px;
            height: 25px;
            padding: 0;
            border: none;
            cursor: pointer;
        }
        select {
            height: 25px;
            margin: 0 5px;
        }
        #text-input {
            position: absolute;
            display: none;
            border: 1px dashed #0366d6;
            background: transparent;
            font-family: Arial;
            z-index: 1000;  /* Updated */
            padding: 5px;
            resize: none;
            overflow: hidden;
            min-width: 100px;  /* Ensure minimum width */
            min-height: 20px;  /* Ensure minimum height */
        }
        #status-message {
            font-style: italic;
            color: #586069;
        }
    </style>
</head>
<body>
    <h1>GitHub Files Viewer with Enhanced Annotations</h1>
    
    <div id="container">
        <div id="file-list">
            <div class="loading-message">Loading files...</div>
        </div>
        
        <div id="main-content">
            <div id="toolbar">
                <div id="pdf-buttons">
                    <div class="button-group">
                        <button id="prev" disabled>← Previous</button>
                        <span id="page-info">Page <span id="page-num">0</span> / <span id="page-count">0</span></span>
                        <button id="next" disabled>Next →</button>
                    </div>
                    
                    <div class="button-group">
                        <button id="zoom-out">-</button>
                        <span id="zoom-level">100%</span>
                        <button id="zoom-in">+</button>
                    </div>
                </div>
                
                <div id="annotation-tools">
                    <button id="draw-tool" title="Draw">Draw</button>
                    <button id="text-tool" title="Add Text">Text</button>
                    <button id="eraser-tool" title="Eraser">Eraser</button>
                    <button id="select-tool" title="Select">Select</button>
                    <input type="color" id="color-picker" value="#FF0000" title="Color">
                    <select id="line-width" title="Line Width">
                        <option value="1">Thin</option>
                        <option value="3" selected>Medium</option>
                        <option value="5">Thick</option>
                        <option value="10">Very Thick</option>
                    </select>
                    <button id="reset-viewer" title="Reset Viewer">Reset</button>
                    <button id="clear-annotations" title="Clear All Annotations">Clear</button>
                    <button id="save-annotations" title="Save Annotations">Save</button>
                    <button id="download-pdf" title="Download PDF with Annotations">Download PDF</button>
                    <button id="practice" title="Generate Practice Questions">Practice</button>
                </div>
            </div>
            
            <div id="pdf-container">
                <div id="pdf-viewer">
                    <canvas id="pdf-canvas"></canvas>
                    <canvas id="annotation-canvas"></canvas>
                    <textarea id="text-input"></textarea>
                </div>
                <div id="status-message"></div>
            </div>
        </div>
    </div>

<script>
// Add fallback PDF URL
const FALLBACK_PDF_URL = "https://raw.githubusercontent.com/mozilla/pdf.js/ba2edeae/web/compressed.tracemonkey-pldi-09.pdf";

// Set up PDF.js
const pdfjsLib = window['pdfjs-dist/build/pdf'];
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

// Variables for PDF viewing
let pdfDoc = null;
let pdfBytes = null; // Store the PDF bytes for PDF-Lib
let pageNum = 1;
let pageRendering = false;
let pageNumPending = null;
let scale = 1.0;
let currentPdfUrl = '';
let currentPdfName = '';
let currentFileLink = null;
let pdfCanvas = document.getElementById('pdf-canvas');
let pdfCtx = pdfCanvas.getContext('2d');
let annotationCanvas = document.getElementById('annotation-canvas');
let annotCtx = annotationCanvas.getContext('2d');
let pdfContainer = document.getElementById('pdf-container');

// Variables for drawing
let isDrawing = false;
let lastX = 0;
let lastY = 0;
let currentTool = 'draw'; // 'draw', 'text', 'eraser', 'select'
let lineWidth = 3;
let strokeColor = '#FF0000';
let textInput = document.getElementById('text-input');
let textPosition = { x: 0, y: 0 };
let textSize = 16;
let selectedTextId = null;
let isMovingText = false;

// Enhanced annotation storage system
let documentAnnotations = {};

// Add these debug functions at the top of your script
function debugLog(message) {
    console.log(`[DEBUG] ${message}`);
}

function getCanvasCoordinates(e, canvas) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
    };
}

// Function to fetch GitHub files
async function fetchGitHubFiles() {
    const owner = 'Laurentsandler';
    const repo = 'unit7';
    const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/Lessons`;
    const fileListDiv = document.getElementById('file-list');

    try {
        const response = await fetch(apiUrl);
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const files = await response.json();
        
        if (!Array.isArray(files)) {
            throw new Error('The API did not return an array of files');
        }

        // Clear loading message
        fileListDiv.innerHTML = '';

        // Add file links to the sidebar
        files.forEach(file => {
            const fileUrl = `https://raw.githubusercontent.com/${owner}/${repo}/main/${file.path}`;
            const fileLink = document.createElement('a');
            fileLink.className = 'file-link';
            fileLink.textContent = file.name;
            fileLink.onclick = function() {
                // Remove active class from previous link
                if (currentFileLink) {
                    currentFileLink.classList.remove('active');
                }
                
                // Add active class to current link
                this.classList.add('active');
                currentFileLink = this;
                
                loadPDF(fileUrl, file.name);
            };
            fileListDiv.appendChild(fileLink);
        });

        // Load the first file by default if there are any files
        if (files.length > 0) {
            const firstFileUrl = `https://raw.githubusercontent.com/${owner}/${repo}/main/${files[0].path}`;
            const firstFileElement = fileListDiv.querySelector('.file-link');
            if (firstFileElement) {
                firstFileElement.classList.add('active');
                currentFileLink = firstFileElement;
            }
            loadPDF(firstFileUrl, files[0].name);
        }
        
        // Load annotations from local storage
        loadAnnotations();
        
    } catch (error) {
        fileListDiv.innerHTML = `<div class="loading-message">Error: ${error.message}<br>Loading fallback PDF for testing.</div>`;
        console.error('Error fetching files:', error);
        
        // Add fallback link
        const fileLink = document.createElement('a');
        fileLink.className = 'file-link active';
        fileLink.textContent = "Test PDF";
        fileLink.onclick = function() {
            loadPDF(FALLBACK_PDF_URL, "Test PDF");
        };
        fileListDiv.appendChild(fileLink);
        currentFileLink = fileLink;
        
        // Load the fallback PDF
        loadPDF(FALLBACK_PDF_URL, "Test PDF");
    }
}

// Function to load and display a PDF
async function loadPDF(url, fileName) {
    try {
        // Cancel any ongoing rendering
        if (pageRendering) {
            pageRendering = false;
            pageNumPending = null;
        }
        
        // Save annotations of current PDF before loading a new one
        if (currentPdfName) {
            saveAnnotations();
        }
        
        // Reset page number and update current URL/name
        pageNum = 1;
        currentPdfUrl = url;
        currentPdfName = fileName;
        
        // Clear current annotation canvas
        clearAnnotationCanvas();
        
        updateStatus('Loading PDF...');
        
        // Fetch and load the PDF
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.status}`);
        }
        
        const arrayBuffer = await response.arrayBuffer();
        pdfBytes = new Uint8Array(arrayBuffer);
        
        // Make sure any previous document is properly destroyed
        if (pdfDoc) {
            pdfDoc.destroy();
            pdfDoc = null;
        }
        
        // Load the new document
        const loadingTask = pdfjsLib.getDocument({data: pdfBytes});
        
        loadingTask.promise.then(function(pdf) {
            pdfDoc = pdf;
            document.getElementById('page-count').textContent = pdf.numPages;
            
            // Enable navigation buttons if there are multiple pages
            document.getElementById('prev').disabled = (pdf.numPages === 1);
            document.getElementById('next').disabled = (pdf.numPages === 1);
            
            // Render the first page
            renderPage(pageNum);
            
        }).catch(function(error) {
            console.error('Error loading PDF:', error);
            updateStatus('Error loading PDF: ' + error.message);
            
            // Show error on the canvas
            pdfCtx.fillStyle = "#f6f8fa";
            pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
            pdfCtx.fillStyle = "#d73a49";
            pdfCtx.font = "20px Arial";
            pdfCtx.textAlign = "center";
            pdfCtx.fillText("Error loading PDF", pdfCanvas.width/2, pdfCanvas.height/2-20);
            pdfCtx.font = "16px Arial";
            pdfCtx.fillText("This may not be a PDF file or it's not accessible", pdfCanvas.width/2, pdfCanvas.height/2+20);
        });
    } catch (error) {
        console.error('Error loading PDF:', error);
        updateStatus('Error loading PDF: ' + error.message);
    }
}

// Enhanced function to render a specific page of the PDF
function renderPage(num) {
    if (pageRendering) {
        // If another page is currently rendering, put this request in the queue
        pageNumPending = num;
        return;
    }
    
    pageRendering = true;
    updateStatus('Rendering page...');
    
    // Get page
    pdfDoc.getPage(num).then(function(page) {
        // Adjust canvas size to the page
         const viewport = page.getViewport({ scale });
    
    // Set both canvas dimensions
    pdfCanvas.height = viewport.height;
    pdfCanvas.width = viewport.width;
    annotationCanvas.height = viewport.height;
    annotationCanvas.width = viewport.width;
        
        // Clear the canvas before rendering new page
        pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        
        // Create a new render context for each render operation
        const renderContext = {
            canvasContext: pdfCtx,
            viewport: viewport
        };
        
        const renderTask = page.render(renderContext);
        
        // Wait for rendering to finish
        renderTask.promise.then(function() {
            pageRendering = false;
            updateStatus('Page rendered.');
            
            // Load annotations for this page/file
            renderAnnotations();
            
            // Check if there's a pending page
            if (pageNumPending !== null) {
                // New page has been requested while this one was rendering
                const pendingNum = pageNumPending;
                pageNumPending = null;
                renderPage(pendingNum);
            }
            
        }).catch(function(error) {
            pageRendering = false;
            updateStatus('Error rendering page: ' + error);
            console.error('Render task error:', error);
        });
    }).catch(function(error) {
        pageRendering = false;
        updateStatus('Error getting page: ' + error);
        console.error('Get page error:', error);
    });
    
    // Update page counters
    document.getElementById('page-num').textContent = num;
}

// Functions to navigate between pages
function queueRenderPage(num) {
    if (pageRendering) {
        pageNumPending = num;
    } else {
        renderPage(num);
    }
}

function onPrevPage() {
    if (pageNum <= 1) {
        return;
    }
    pageNum--;
    queueRenderPage(pageNum);
}

function onNextPage() {
    if (pageNum >= pdfDoc.numPages) {
        return;
    }
    pageNum++;
    queueRenderPage(pageNum);
}

// Function to update status message
function updateStatus(message) {
    const statusElement = document.getElementById('status-message');
    statusElement.textContent = message;
    // Clear message after 3 seconds
    setTimeout(() => {
        if (statusElement.textContent === message) {
            statusElement.textContent = '';
        }
    }, 3000);
}

// Function for zoom in
function zoomIn() {
    if (scale >= 3.0) return; // Max zoom
    scale += 0.25;
    updateZoomDisplay();
    queueRenderPage(pageNum);
}

// Function for zoom out
function zoomOut() {
    if (scale <= 0.5) return; // Min zoom
    scale -= 0.25;
    updateZoomDisplay();
    queueRenderPage(pageNum);
}

// Update zoom level display
function updateZoomDisplay() {
    document.getElementById('zoom-level').textContent = `${Math.round(scale * 100)}%`;
}

// New Enhanced Annotation System
// Instead of separate storages, use a unified structure
function initializeAnnotationsForCurrentDocument() {
    if (!currentPdfName) return; // Add this check
    
    if (!documentAnnotations[currentPdfName]) {
        documentAnnotations[currentPdfName] = {};
    }
    
    if (!documentAnnotations[currentPdfName][pageNum]) {
        documentAnnotations[currentPdfName][pageNum] = {
            drawings: [],
            texts: []
        };
    }
}

// Draw annotations on the canvas
function renderAnnotations() {
    // Clear the annotation canvas first
    clearAnnotationCanvas();
    
    if (!currentPdfName) return;
    
    initializeAnnotationsForCurrentDocument();
    const pageAnnotations = documentAnnotations[currentPdfName][pageNum];
    
    // Render drawing annotations
    for (const drawing of pageAnnotations.drawings) {
        annotCtx.beginPath();
        annotCtx.strokeStyle = drawing.color;
        annotCtx.lineWidth = drawing.lineWidth;
        annotCtx.lineJoin = 'round';
        annotCtx.lineCap = 'round';
        
        // Draw the path
        if (drawing.points.length > 0) {
            annotCtx.moveTo(drawing.points[0].x, drawing.points[0].y);
            
            for (let i = 1; i < drawing.points.length; i++) {
                annotCtx.lineTo(drawing.points[i].x, drawing.points[i].y);
            }
        }
        
        annotCtx.stroke();
    }
    
    // Render text annotations
    for (const text of pageAnnotations.texts) {
        renderTextAnnotation(text);
    }
}

// Function to render a text annotation
function renderTextAnnotation(textObj) {
    // Render the text on the canvas
    annotCtx.font = `${textObj.size}px Arial`;
    annotCtx.fillStyle = textObj.color;
    annotCtx.textBaseline = 'top';
    annotCtx.fillText(textObj.text, textObj.x, textObj.y);
    
    // Draw a small "x" delete button
    const textWidth = annotCtx.measureText(textObj.text).width;
    const xSize = textObj.size * 0.8; // Size of the "x" relative to text
    
    annotCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
    annotCtx.fillRect(textObj.x + textWidth + 2, textObj.y - 2, xSize, xSize);
    
    annotCtx.fillStyle = 'white';
    annotCtx.font = `${xSize * 0.8}px Arial`;
    annotCtx.textBaseline = 'top';
    annotCtx.fillText('×', textObj.x + textWidth + 3, textObj.y - 1);
    
    // Add event listener for "x" click
    annotationCanvas.addEventListener('click', function(e) {
        const coords = getCanvasCoordinates(e, annotationCanvas);
        if (coords.x >= textObj.x + textWidth + 2 && coords.x <= textObj.x + textWidth + 2 + xSize &&
            coords.y >= textObj.y - 2 && coords.y <= textObj.y - 2 + xSize) {
            deleteTextAnnotation(textObj.id);
        }
    });
}

// Function to delete text annotation
function deleteTextAnnotation(textId) {
    if (!currentPdfName || !documentAnnotations[currentPdfName] || !documentAnnotations[currentPdfName][pageNum]) return;
    
    const textIndex = documentAnnotations[currentPdfName][pageNum].texts.findIndex(t => t.id === textId);
    if (textIndex !== -1) {
        documentAnnotations[currentPdfName][pageNum].texts.splice(textIndex, 1);
        renderAnnotations();
        saveAnnotations();
    }
}

// Function to clear annotation canvas
function clearAnnotationCanvas() {
    annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
}

// Function to clear all annotations on current page
function clearCurrentPageAnnotations() {
    if (!currentPdfName) return;
    
    initializeAnnotationsForCurrentDocument();
    
    // Clear annotations for current page
    documentAnnotations[currentPdfName][pageNum] = {
        drawings: [],
        texts: []
    };
    
    // Clear the canvas
    clearAnnotationCanvas();
    updateStatus('Annotations cleared from current page');
    saveAnnotations();
}

// Generate unique ID for text annotations
function generateUniqueId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

// Function to show text input
function showTextInput(x, y) {
    debugLog(`Showing text input at x=${x}, y=${y}`);
    
    const rect = annotationCanvas.getBoundingClientRect();
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    // Store position for later use
    textPosition = {x, y};
    
    // Calculate absolute position
    const absoluteX = rect.left + x + scrollLeft;
    const absoluteY = rect.top + y + scrollTop;
    
    debugLog(`Absolute position: x=${absoluteX}, y=${absoluteY}`);
    
    // Position and show the text input
    textInput.style.position = 'absolute';
    textInput.style.left = `${absoluteX}px`;
    textInput.style.top = `${absoluteY}px`;
    textInput.style.display = 'block';
    textInput.style.zIndex = '1000';  // Ensure it's above other elements
    textInput.style.color = strokeColor;
    textInput.style.fontSize = `${textSize}px`;
    textInput.value = '';
    textInput.style.minWidth = '100px';  // Ensure minimum width
    textInput.style.minHeight = '20px';  // Ensure minimum height
    
    // Focus the input
    setTimeout(() => {
        textInput.focus();
    }, 10);
}

// Function to hide text input
function hideTextInput() {
    textInput.style.display = 'none';
    textInput.value = '';
}

// Function to commit text entry (continuing from where it was cut off)
function commitText() {
    if (!textInput.value.trim()) {
        hideTextInput();
        return;
    }
    
    initializeAnnotationsForCurrentDocument();
    
    // Check if we're editing an existing text
    if (selectedTextId) {
        const textIndex = documentAnnotations[currentPdfName][pageNum].texts.findIndex(t => t.id === selectedTextId);
        
        if (textIndex !== -1) {
            // Update existing text
            documentAnnotations[currentPdfName][pageNum].texts[textIndex].text = textInput.value;
        } else {
            // Add new text if somehow the ID is not found
            addNewTextAnnotation();
        }
        
        selectedTextId = null;
    } else {
        // Add new text
        addNewTextAnnotation();
    }
    
    hideTextInput();
    renderAnnotations();
    saveAnnotations();
}

// Helper function to add new text annotation
function addNewTextAnnotation() {
    const textAnnotation = {
        id: generateUniqueId(),
        text: textInput.value,
        x: textPosition.x,
        y: textPosition.y,
        size: textSize,
        color: strokeColor
    };
    
    documentAnnotations[currentPdfName][pageNum].texts.push(textAnnotation);
}

// Set active tool
function setActiveTool(tool) {
    currentTool = tool;
    
    // Update button appearances
    document.getElementById('draw-tool').classList.remove('active');
    document.getElementById('text-tool').classList.remove('active');
    document.getElementById('eraser-tool').classList.remove('active');
    document.getElementById('select-tool').classList.remove('active');
    
    // Cancel any ongoing operations
    isDrawing = false;
    isMovingText = false;
    
    if (tool === 'draw') {
        document.getElementById('draw-tool').classList.add('active');
        annotationCanvas.style.cursor = 'crosshair';
    } else if (tool === 'text') {
        document.getElementById('text-tool').classList.add('active');
        annotationCanvas.style.cursor = 'text';
    } else if (tool === 'eraser') {
        //document.getElementById('eraser-tool').classList.add('active');
        //annotationCanvas.style.cursor = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAC/SURBVDhP7ZLBDYMwDEWzVwbJHhmCuTJHJskOOXfuMARrdIn8ayUIuKGHSnnSlyDxbH+HgH/EdKKuaxtvyKJ4gs9GP81YwjCsgqIowrZt4VTuz3OxbVv4JfKmaRQWRXEJUmRZpjCO4xDwCCkiG1jXtcIwDEPAI6TIAM/zXGHf9yHgEVJkgOM4Kuz7PgQ8QorMtu/7KoT6vhdSSHYAUsQF67pWIZYQC2ZZJqSQ7ACkKOZ5rrCqqitt20bGsWf/Cdz8McwbZMJ4JupGFPoAAAAASUVORK5CYII="), auto`;
    } else if (tool === 'select') {
        document.getElementById('select-tool').classList.add('active');
        annotationCanvas.style.cursor = 'default';
    }
    
    // Hide text input if shown
    if (textInput.style.display === 'block') {
        if (textInput.value.trim() !== '') {
            commitText();
        } else {
            hideTextInput();
        }
    }
}

// Event handlers for drawing
function startDrawing(e) {
    e.preventDefault();
    debugLog(`Tool: ${currentTool}`);
    
    if (!currentPdfName || !documentAnnotations[currentPdfName]) {
        debugLog('No PDF loaded or annotations not initialized');
        return;
    }
    
    const coords = getCanvasCoordinates(e, annotationCanvas);
    debugLog(`Start coordinates: x=${coords.x}, y=${coords.y}`);
    
    // Initialize if needed
    if (!documentAnnotations[currentPdfName][pageNum]) {
        documentAnnotations[currentPdfName][pageNum] = {
            drawings: [],
            texts: []
        };
    }
    
    if (currentTool === 'text') {
        debugLog('Showing text input');
        showTextInput(coords.x, coords.y);
        return;
    }
    
    if (currentTool === 'draw') {
        isDrawing = true;
        lastX = coords.x;
        lastY = coords.y;
        
        debugLog('Starting new drawing path');
        // Start new drawing path
        documentAnnotations[currentPdfName][pageNum].drawings.push({
            color: strokeColor,
            lineWidth: lineWidth,
            points: [{x: coords.x, y: coords.y}]
        });
        
        // Set up canvas context
        annotCtx.beginPath();
        annotCtx.strokeStyle = strokeColor;
        annotCtx.lineWidth = lineWidth;
        annotCtx.lineJoin = 'round';
        annotCtx.lineCap = 'round';
        annotCtx.moveTo(coords.x, coords.y);
    }
}

function draw(e) {
    e.preventDefault();
    
    if (!isDrawing || currentTool !== 'draw') {
        return;
    }
    
    const coords = getCanvasCoordinates(e, annotationCanvas);
    debugLog(`Drawing coordinates: x=${coords.x}, y=${coords.y}`);
    
    if (!documentAnnotations[currentPdfName] || 
        !documentAnnotations[currentPdfName][pageNum] || 
        !documentAnnotations[currentPdfName][pageNum].drawings.length) {
        debugLog('No active drawing path');
        return;
    }
    
    // Get current drawing
    const currentDrawing = documentAnnotations[currentPdfName][pageNum].drawings[
        documentAnnotations[currentPdfName][pageNum].drawings.length - 1
    ];
    
    // Add new point
    currentDrawing.points.push({x: coords.x, y: coords.y});
    
    // Draw line
    annotCtx.beginPath();
    annotCtx.strokeStyle = currentDrawing.color;
    annotCtx.lineWidth = currentDrawing.lineWidth;
    annotCtx.lineJoin = 'round';
    annotCtx.lineCap = 'round';
    annotCtx.moveTo(lastX, lastY);
    annotCtx.lineTo(coords.x, coords.y);
    annotCtx.stroke();
    
    lastX = coords.x;
    lastY = coords.y;
}

function stopDrawing() {
    if (isDrawing) {
        isDrawing = false;
        saveAnnotations();
    }
    
    if (isMovingText) {
        isMovingText = false;
        selectedTextId = null;
        saveAnnotations();
    }
}

// Load annotations from localStorage
function loadAnnotations() {
    try {
        const savedAnnotations = localStorage.getItem('pdfAnnotations');
        
        if (savedAnnotations) {
            documentAnnotations = JSON.parse(savedAnnotations);
            updateStatus('Annotations loaded from local storage.');
        }
    } catch (error) {
        console.error('Error loading annotations:', error);
        updateStatus('Error loading saved annotations: ' + error.message);
    }
}

// Save annotations to localStorage
function saveAnnotations() {
    if (!currentPdfName) return;
    
    try {
        localStorage.setItem('pdfAnnotations', JSON.stringify(documentAnnotations));
    } catch (error) {
        console.error('Error saving annotations:', error);
        updateStatus('Error saving annotations: ' + error.message);
    }
}

// Function to download PDF with annotations
async function downloadAnnotatedPdf() {
    if (!pdfBytes) {
        updateStatus('No PDF loaded to download');
        return;
    }
    
    updateStatus('Preparing PDF download...');
    
    try {
        // Load the PDF document with PDF-Lib
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        const pages = pdfDoc.getPages();
        
        // Check if we have any annotations to add
        let hasAnnotations = false;
        for (const pageKey in documentAnnotations[currentPdfName]) {
            const pageAnnots = documentAnnotations[currentPdfName][pageKey];
            if (pageAnnots && (pageAnnots.texts.length > 0 || pageAnnots.drawings.length > 0)) {
                hasAnnotations = true;
                break;
            }
        }
        
        if (!hasAnnotations) {
            updateStatus('No annotations to add to PDF');
            return;
        }
        
        // Process each page with annotations
        for (const pageKey in documentAnnotations[currentPdfName]) {
            const pageNum = parseInt(pageKey);
            if (isNaN(pageNum) || pageNum <= 0 || pageNum > pages.length) continue;
            
            const pageAnnots = documentAnnotations[currentPdfName][pageKey];
            if (!pageAnnots) continue;
            
            const page = pages[pageNum - 1]; // PDF-Lib uses 0-based indexing
            
            // Get page dimensions
            const { width, height } = page.getSize();
            
            // Add text annotations
            if (pageAnnots.texts && pageAnnots.texts.length > 0) {
                for (const textAnnot of pageAnnots.texts) {
                    // Convert color from hex to RGB
                    const color = hexToRgb(textAnnot.color);
                    
                    page.drawText(textAnnot.text, {
                        x: textAnnot.x,
                        y: height - textAnnot.y - textAnnot.size, // Convert to PDF coordinates (origin at bottom-left)
                        size: textAnnot.size,
                        color: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255)
                    });
                }
            }
            
            // Add drawing annotations
            if (pageAnnots.drawings && pageAnnots.drawings.length > 0) {
                for (const drawing of pageAnnots.drawings) {
                    if (!drawing.points || drawing.points.length < 2) continue; // Skip single points
                    
                    // Convert color
                    const color = hexToRgb(drawing.color);
                    
                    // Create an SVG path
                    let svgPath = `M ${drawing.points[0].x} ${height - drawing.points[0].y} `;
                    for (let i = 1; i < drawing.points.length; i++) {
                        svgPath += `L ${drawing.points[i].x} ${height - drawing.points[i].y} `;
                    }
                    
                    // Draw the SVG path
                    page.drawSvgPath(svgPath, {
                        color: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255),
                        borderWidth: drawing.lineWidth,
                        borderColor: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255)
                    });
                }
            }
        }
        
        // Save the PDF
        const newPdfBytes = await pdfDoc.save();
        
        // Create a download link
        const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
        const filename = currentPdfName.replace(/\.[^/.]+$/, '') + '_annotated.pdf';
        
        // Use the download.js library
        download(blob, filename, 'application/pdf');
        
        updateStatus('PDF downloaded with annotations');
    } catch (error) {
        console.error('Error creating annotated PDF:', error);
        updateStatus('Error creating annotated PDF: ' + error.message);
    }
}
// Helper function to convert hex color to RGB (continuing from where it was cut off)
function hexToRgb(hex) {
    // Remove the # if present
    hex = hex.replace(/^#/, '');
    
    // Parse r, g, b values
    let bigint = parseInt(hex, 16);
    let r = (bigint >> 16) & 255;
    let g = (bigint >> 8) & 255;
    let b = bigint & 255;
    
    return { r, g, b };
}

// Double-click handler for editing text
function setupTextEditing() {
    annotationCanvas.addEventListener('dblclick', function(e) {
        if (currentTool !== 'select') return;
        
        const rect = annotationCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Check if double-clicked on text
        if (documentAnnotations[currentPdfName] && 
            documentAnnotations[currentPdfName][pageNum] &&
            documentAnnotations[currentPdfName][pageNum].texts) {
            
            const texts = documentAnnotations[currentPdfName][pageNum].texts;
            
            for (const textObj of texts) {
                annotCtx.font = `${textObj.size}px Arial`;
                const textWidth = annotCtx.measureText(textObj.text).width;
                
                if (x >= textObj.x && x <= textObj.x + textWidth &&
                    y >= textObj.y && y <= textObj.y + textObj.size) {
                    
                    // Set up text input for editing
                    selectedTextId = textObj.id;
                    textPosition.x = textObj.x;
                    textPosition.y = textObj.y;
                    
                    const viewportX = rect.left + textObj.x;
                    const viewportY = rect.top + textObj.y;
                    
                    textInput.style.position = 'absolute';
                    textInput.style.left = viewportX + 'px';
                    textInput.style.top = viewportY + 'px';
                    textInput.style.display = 'block';
                    textInput.style.color = textObj.color;
                    textInput.style.fontSize = textObj.size + 'px';
                    textInput.value = textObj.text;
                    
                    setTimeout(() => {
                        textInput.focus();
                        textInput.select();
                    }, 10);
                    
                    return;
                }
            }
        }
    });
}

// Function to handle viewer reset
function resetViewer() {
    // Cancel any pending operations
    if (pdfDoc) {
        try {
            pdfDoc.destroy();
        } catch (error) {
            console.error('Error destroying PDF document:', error);
        }
        pdfDoc = null;
    }
    
    // Clear canvas
    pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
    annotCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    
    // Reset state
    pageNum = 1;
    pageRendering = false;
    pageNumPending = null;
    scale = 1.0;
    updateZoomDisplay();
    
    // Reload current PDF if available
    if (currentPdfUrl && currentPdfName) {
        loadPDF(currentPdfUrl, currentPdfName);
    }
    
    updateStatus('Viewer reset');
}

// Function to ensure proper canvas setup
function setupCanvas() {
    debugLog('Setting up canvas');
    
    // Make sure both canvases have the same dimensions as the container
    const container = document.getElementById('pdf-container');
    const containerRect = container.getBoundingClientRect();
    
    pdfCanvas.width = containerRect.width;
    pdfCanvas.height = containerRect.height;
    annotationCanvas.width = containerRect.width;
    annotationCanvas.height = containerRect.height;
    
    // Clear any existing transformations
    pdfCtx.setTransform(1, 0, 0, 1, 0, 0);
    annotCtx.setTransform(1, 0, 0, 1, 0, 0);
    
    // Enable image smoothing
    pdfCtx.imageSmoothingEnabled = true;
    annotCtx.imageSmoothingEnabled = true;
}

// Set up all event handlers
function setupEventHandlers() {
    // PDF navigation buttons
    document.getElementById('prev').addEventListener('click', onPrevPage);
    document.getElementById('next').addEventListener('click', onNextPage);
    document.getElementById('reset-viewer').addEventListener('click', resetViewer);
    
    // Zoom buttons
    document.getElementById('zoom-in').addEventListener('click', zoomIn);
    document.getElementById('zoom-out').addEventListener('click', zoomOut);
    
    // Tool buttons
    document.getElementById('draw-tool').addEventListener('click', () => setActiveTool('draw'));
    document.getElementById('text-tool').addEventListener('click', () => setActiveTool('text'));
    document.getElementById('eraser-tool').addEventListener('click', () => setActiveTool('eraser'));
    document.getElementById('select-tool').addEventListener('click', () => setActiveTool('select'));
    document.getElementById('clear-annotations').addEventListener('click', clearCurrentPageAnnotations);
    document.getElementById('save-annotations').addEventListener('click', saveAnnotations);
    document.getElementById('download-pdf').addEventListener('click', downloadAnnotatedPdf);
    
    // Color and line width controls
    document.getElementById('color-picker').addEventListener('input', function(e) {
        strokeColor = e.target.value;
    });
    
    document.getElementById('line-width').addEventListener('change', function(e) {
        lineWidth = parseInt(e.target.value);
    });
    
    // Drawing event listeners
    annotationCanvas.addEventListener('mousedown', startDrawing);
    annotationCanvas.addEventListener('mousemove', draw);
    annotationCanvas.addEventListener('mouseup', stopDrawing);
    annotationCanvas.addEventListener('mouseout', stopDrawing);
    
    // Text input event listeners
    textInput.addEventListener('blur', commitText);
    textInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            commitText();
        }
        
        // Allow escape to cancel
        if (e.key === 'Escape') {
            hideTextInput();
            selectedTextId = null;
        }
    });
    
    // Set up text editing via double-click
    setupTextEditing();
    
    // Handle touch events for mobile devices
    annotationCanvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            startDrawing(mouseEvent);
        }
    }, { passive: false });
    
    annotationCanvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            draw(mouseEvent);
        }
    }, { passive: false });
    
    annotationCanvas.addEventListener('touchend', stopDrawing);
    
    // Update canvas setup when window is resized
    window.addEventListener('resize', setupCanvas);
}

// Initialize the application
function initApp() {
    setupCanvas();
    setActiveTool('draw');
    setupEventHandlers();
    fetchGitHubFiles();
    
    // Add error handling for worker
    pdfjsLib.GlobalWorkerOptions.onError = function(error) {
        console.error('PDF.js Worker Error:', error);
        updateStatus('PDF Worker Error: ' + error.message);
    };
}

// Start the application when DOM is fully loaded
document.addEventListener('DOMContentLoaded', initApp);

// Function to handle the API request and response
async function generatePracticeQuestions() {
    if (!currentPdfUrl) {
        updateStatus('No PDF loaded to generate practice questions');
        return;
    }

    updateStatus('Generating practice questions...');

    try {
        const questions = await createStreamChat(currentPdfUrl);
        redirectToPracticePage(questions);
    } catch (error) {
        console.error('Error generating practice questions:', error);
        updateStatus('Error generating practice questions: ' + error.message);
    }
}

// Function to redirect to the practice page with generated questions
function redirectToPracticePage(questions) {
    const practicePageUrl = 'practice.html';
    const queryParams = new URLSearchParams({ questions: JSON.stringify(questions) });
    window.location.href = `${practicePageUrl}?${queryParams.toString()}`;
}

// Add event listener for the "Practice" button
document.getElementById('practice').addEventListener('click', generatePracticeQuestions);

// Function to create a stream chat using Vertex AI
async function createStreamChat(pdfUrl) {
    const { VertexAI } = require('@google-cloud/vertexai');

    const projectId = 'PROJECT_ID';
    const location = 'us-central1';
    const model = 'gemini-1.5-flash-001';

    // Initialize Vertex with your Cloud project and location
    const vertexAI = new VertexAI({ project: projectId, location: location });

    // Instantiate the model
    const generativeModel = vertexAI.getGenerativeModel({
        model: model,
    });

    const chat = generativeModel.startChat({});
    const chatInput1 = `Generate 10 practice questions based on the questions in the PDF at ${pdfUrl}`;

    console.log(`User: ${chatInput1}`);

    const result1 = await chat.sendMessageStream(chatInput1);
    const questions = [];
    for await (const item of result1.stream) {
        questions.push(item.candidates[0].content.parts[0].text);
    }

    return questions;
}
</script>
</body>
</html>
<script async data-explicit-opt-in="true" data-deployment-id="dpl_Ae2ZJ2BYqK7yZJ5Hvo5VgCv6Gxfk" src="https://vercel.live/_next-live/feedback/feedback.js"></script>
